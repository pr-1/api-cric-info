{"version":3,"sources":["AutoMapperBase.ts"],"names":[],"mappings":"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","file":"AutoMapperBase.js","sourcesContent":["/// <reference path=\"../../dist/automapper-interfaces.d.ts\" />\r\n/// <reference path=\"TypeConverter.ts\" />\r\n/// <reference path=\"AutoMapperHelper.ts\" />\r\n/// <reference path=\"AutoMapperValidator.ts\" />\r\n\r\nmodule AutoMapperJs {\r\n    'use strict';\r\n\r\n    // interface shorthands\r\n    type IFluentFunc = ICreateMapFluentFunctions;\r\n    type IDMCO = IMemberConfigurationOptions;\r\n    type ISMCO = ISourceMemberConfigurationOptions;\r\n\r\n    type stringOrClass = string | (new () => any);\r\n\r\n    /**\r\n     * AutoMapper implementation, for both creating maps and performing maps. Comparable usage and functionality to the original\r\n     * .NET AutoMapper library is the pursuit of this implementation.\r\n     */\r\n    export abstract class AutoMapperBase {\r\n\r\n        public abstract map(sourceKeyOrType: any, destinationKeyOrType: any, sourceObject: any): any;\r\n\r\n        public abstract createMap(sourceKeyOrType: string | (new () => any), destinationKeyOrType: string | (new () => any)): any;\r\n\r\n        protected getMapping(mappings: { [key: string]: IMapping }, sourceKey: stringOrClass, destinationKey: stringOrClass): IMapping {\r\n            let srcKey = this.getKey(sourceKey);\r\n            let dstKey = this.getKey(destinationKey);\r\n            let mapping: IMapping = mappings[srcKey + dstKey];\r\n\r\n            if (!mapping) {\r\n                throw new Error(`Could not find map object with a source of ${srcKey} and a destination of ${dstKey}`);\r\n            }\r\n            return mapping;\r\n        }\r\n\r\n        protected getKey(keyStringOrType: string | (new () => any)): string {\r\n            if (typeof keyStringOrType === 'string') {\r\n                return keyStringOrType;\r\n            } else {\r\n                return AutoMapperHelper.getClassName(keyStringOrType);\r\n            }\r\n        }\r\n\r\n        protected isArray(sourceObject: any): boolean {\r\n            return sourceObject instanceof Array;\r\n        }\r\n\r\n        protected handleArray(mapping: IMapping, sourceArray: Array<any>, itemFunc: (sourceObject: any, destinationObject: any) => void): Array<any> {\r\n            var arrayLength = sourceArray.length;\r\n            var destinationArray = new Array<any>(sourceArray.length);\r\n\r\n            for (let index = 0; index < arrayLength; index++) {\r\n                let sourceObject = sourceArray[index];\r\n                let destinationObject: any;\r\n\r\n                if (sourceObject === null || sourceObject === undefined) {\r\n                    destinationObject = sourceObject;\r\n                } else {\r\n                    destinationObject = this.createDestinationObject(mapping.destinationTypeClass);\r\n                    itemFunc(sourceObject, destinationObject);\r\n                }\r\n\r\n                destinationArray[index] = destinationObject;\r\n            }\r\n\r\n            return destinationArray;\r\n        }\r\n\r\n        protected handleItem(mapping: IMapping, sourceObject: any, destinationObject: any, propertyFunction: (propertyName: string) => void): any {\r\n            // var sourceProperties: string[] = [];\r\n            var atLeastOnePropertyMapped = false;\r\n\r\n            // handle mapped properties ...\r\n            for (let property of mapping.properties) {\r\n                // sourceProperties.push(property.name);\r\n\r\n                atLeastOnePropertyMapped = true;\r\n                propertyFunction(property.name);\r\n            }\r\n\r\n            // .. and, after that, handle unmapped properties\r\n            for (let sourcePropertyName in sourceObject) {\r\n                if (!sourceObject.hasOwnProperty(sourcePropertyName)) {\r\n                    continue;\r\n                }\r\n\r\n                atLeastOnePropertyMapped = true;\r\n                propertyFunction(sourcePropertyName);\r\n            }\r\n\r\n            // return null/undefined sourceObject if no properties added\r\n            if (!atLeastOnePropertyMapped && (sourceObject === null || sourceObject === undefined)) {\r\n                return sourceObject;\r\n            }\r\n\r\n            return destinationObject;\r\n        }\r\n\r\n        protected handleProperty(\r\n            mapping: IMapping,\r\n            sourceObject: any,\r\n            sourcePropertyName: string,\r\n            destinationObject: any,\r\n            transformFunction: (destinationProperty: IDestinationProperty, memberOptions: IDMCO, callback?: IMemberCallback) => void,\r\n            autoMappingCallbackFunction?: (dstPropVal: any) => void): void {\r\n\r\n            // TODO Property mappings are already located before\r\n            // TODO handleProperty seems only to be called when processing a mapped property.\r\n            var propertyMappings = this.getPropertyMappings(mapping.properties, sourcePropertyName);\r\n            if (propertyMappings.length > 0) {\r\n                for (let propertyMapping of propertyMappings) {\r\n                    this.processMappedProperty(mapping, propertyMapping, sourceObject, sourcePropertyName, transformFunction);\r\n                }\r\n            } else {\r\n                this.handlePropertyWithAutoMapping(mapping, sourceObject, sourcePropertyName, destinationObject, autoMappingCallbackFunction);\r\n            }\r\n        }\r\n\r\n        protected setPropertyValue(mapping: IMapping, destinationProperty: IDestinationProperty, destinationObject: any, destinationPropertyValue: any): void {\r\n            if (mapping.forAllMemberMappings.length > 0) {\r\n                for (let forAllMemberMapping of mapping.forAllMemberMappings) {\r\n                    forAllMemberMapping(destinationObject, destinationProperty.name, destinationPropertyValue);\r\n                }\r\n            } else {\r\n                destinationObject[destinationProperty.name] = destinationPropertyValue;\r\n            }\r\n        }\r\n\r\n        protected setPropertyValueByName(mapping: IMapping, destinationObject: any, destinationProperty: string, destinationPropertyValue: any): void {\r\n            if (mapping.forAllMemberMappings.length > 0) {\r\n                for (let forAllMemberMapping of mapping.forAllMemberMappings) {\r\n                    forAllMemberMapping(destinationObject, destinationProperty, destinationPropertyValue);\r\n                }\r\n            } else {\r\n                destinationObject[destinationProperty] = destinationPropertyValue;\r\n            }\r\n        }\r\n\r\n        protected createDestinationObject(destinationType: new () => any): any {\r\n            // create empty destination object.\r\n            return destinationType\r\n                ? new destinationType()\r\n                : {};\r\n        }\r\n\r\n        protected shouldProcessDestination(destination: IDestinationProperty, sourceObject: any): boolean {\r\n            if (destination.ignore) {\r\n                // ignore ignored properties\r\n                return false;\r\n            }\r\n\r\n            if (destination.conditionFunction) {\r\n                // check for condition function, and, if there is ...\r\n                if (destination.conditionFunction(sourceObject) === false) {\r\n                    // ... return when the condition is not met.\r\n                    return false;\r\n                }\r\n            }\r\n\r\n            return true;\r\n        }\r\n\r\n        // protected throwMappingException(propertyMapping: IProperty, message: string): void {\r\n        //     throw new Error(`Cannot map '${propertyMapping.sourcePropertyName}' to '${propertyMapping.destinationPropertyName}' => ${message}`);\r\n        // }\r\n\r\n        private handlePropertyWithAutoMapping(mapping: IMapping,\r\n            sourceObject: any,\r\n            sourcePropertyName: string,\r\n            destinationObject: any,\r\n            autoMappingCallbackFunction?: (dstPropVal: any) => void): void {\r\n            // no forMember mapping exists, auto map properties, except for the situation where ignoreAllNonExisting is specified.\r\n            if (mapping.ignoreAllNonExisting) {\r\n                return;\r\n            }\r\n\r\n            if (mapping.destinationTypeClass && Object.keys(destinationObject).indexOf(sourcePropertyName) < 0) {\r\n                return;\r\n            }\r\n\r\n            let objectValue: any = null;\r\n            let isNestedObject = false;\r\n\r\n            if (typeof destinationObject[sourcePropertyName] === 'object' && destinationObject[sourcePropertyName]) {\r\n                isNestedObject = (destinationObject[sourcePropertyName].constructor.name !== 'Object');\r\n\r\n                if (isNestedObject) {\r\n                    this\r\n                        .createMap(sourceObject[sourcePropertyName].constructor.name, destinationObject[sourcePropertyName].constructor.name)\r\n                        .convertToType(destinationObject[sourcePropertyName].constructor);\r\n\r\n                    objectValue = this.map(\r\n                        sourceObject[sourcePropertyName].constructor.name,\r\n                        destinationObject[sourcePropertyName].constructor.name,\r\n                        sourceObject[sourcePropertyName]\r\n                    );\r\n                }\r\n            }\r\n\r\n            // use profile mapping when specified; otherwise, specify source property name as destination property name.\r\n            let destinationPropertyName = this.getDestinationPropertyName(mapping.profile, sourcePropertyName);\r\n            let destinationPropertyValue = this.getDestinationPropertyValue(sourceObject, sourcePropertyName, objectValue, isNestedObject);\r\n            this.setPropertyValueByName(mapping, destinationObject, destinationPropertyName, destinationPropertyValue);\r\n            if (autoMappingCallbackFunction) {\r\n                autoMappingCallbackFunction(destinationPropertyValue);\r\n            }\r\n        }\r\n\r\n        private getDestinationPropertyValue(sourceObject: any,\r\n            sourcePropertyName: string,\r\n            objectValue: any,\r\n            isNestedObject: boolean): any {\r\n            if (isNestedObject) {\r\n                return objectValue;\r\n            }\r\n\r\n            return sourceObject ? sourceObject[sourcePropertyName] : null;\r\n\r\n        }\r\n\r\n        private getDestinationPropertyName(profile: IProfile, sourcePropertyName: string): string {\r\n            if (!profile) {\r\n                return sourcePropertyName;\r\n            }\r\n\r\n            // TODO BL no support yet for INamingConvention.splittingCharacter\r\n\r\n            try {\r\n                // First, split the source property name based on the splitting expression.\r\n                // TODO BL Caching of RegExp splitting!\r\n                var sourcePropertyNameParts = sourcePropertyName.split(profile.sourceMemberNamingConvention.splittingExpression);\r\n\r\n                // NOTE BL For some reason, splitting by (my ;)) RegExp results in empty strings in the array; remove them.\r\n                for (let index = sourcePropertyNameParts.length - 1; index >= 0; index--) {\r\n                    if (sourcePropertyNameParts[index] === '') {\r\n                        sourcePropertyNameParts.splice(index, 1);\r\n                    }\r\n                }\r\n\r\n                return profile.destinationMemberNamingConvention.transformPropertyName(sourcePropertyNameParts);\r\n            } catch (error) {\r\n                return sourcePropertyName;\r\n            }\r\n        }\r\n\r\n        private getPropertyMappings(properties: ISourceProperty[], sourcePropertyName: string): ISourceProperty[] {\r\n            var result = <ISourceProperty[]>[];\r\n            for (let property of properties) {\r\n                if (property.name === sourcePropertyName) {\r\n                    result.push(property);\r\n                }\r\n            }\r\n            return result;\r\n        }\r\n\r\n        private processMappedProperty(mapping: IMapping,\r\n            propertyMapping: ISourceProperty,\r\n            sourceObject: any,\r\n            sourcePropertyName: string,\r\n            transformFunction: (destinationProperty: IDestinationProperty, memberOptions: IDMCO) => void): void {\r\n            if (propertyMapping.children && propertyMapping.children.length > 0) {\r\n                // always pass child source object, even if source object does not exist =>\r\n                // constant transformations should always pass.\r\n                var childSourceObject = sourceObject ? sourceObject[propertyMapping.name] : null;\r\n                for (let child of propertyMapping.children) {\r\n                    this.processMappedProperty(mapping, child, childSourceObject, child.name, transformFunction);\r\n                    return;\r\n                }\r\n            }\r\n\r\n            var destination = propertyMapping.destination;\r\n            // if (!propertyMapping.destination) {\r\n            //     // it makes no sense to handle a property without destination(s).\r\n            //     this.throwMappingException(propertyMapping, 'no destination object');\r\n            // }\r\n\r\n            let configurationOptions = this.createMemberConfigurationOptions(sourceObject, sourcePropertyName);\r\n            transformFunction(destination, configurationOptions);\r\n        }\r\n\r\n        private createMemberConfigurationOptions(sourceObject: any, sourcePropertyName: string): IMemberConfigurationOptions {\r\n            var memberConfigurationOptions = {\r\n                mapFrom: (sourcePropertyName: string): void => {\r\n                    // no action required, just here as a stub to prevent calling a non-existing 'opts.mapFrom(...)' function.\r\n                },\r\n                condition: (predicate: ((sourceObject: any) => boolean)): void => {\r\n                    // no action required, just here as a stub to prevent calling a non-existing 'opts.condition(...)' function.\r\n                },\r\n                ignore: (): void => {\r\n                    // no action required, just here as a stub to prevent calling a non-existing 'opts.ignore()' function.\r\n                },\r\n                sourceObject: sourceObject,\r\n                sourcePropertyName: sourcePropertyName,\r\n                intermediatePropertyValue: sourceObject ? sourceObject[sourcePropertyName] : sourceObject\r\n            };\r\n            return memberConfigurationOptions;\r\n        }\r\n    }\r\n}\r\n"]}