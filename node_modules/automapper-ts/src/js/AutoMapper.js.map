{"version":3,"sources":["AutoMapper.ts"],"names":[],"mappings":"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","file":"AutoMapper.js","sourcesContent":["/// <reference path=\"../../dist/automapper-interfaces.d.ts\" />\r\n/// <reference path=\"AutoMapperEnumerations.ts\" />\r\n/// <reference path=\"AutoMapperBase.ts\" />\r\n/// <reference path=\"AsyncAutoMapper.ts\" />\r\n/// <reference path=\"TypeConverter.ts\" />\r\n/// <reference path=\"AutoMapperHelper.ts\" />\r\n/// <reference path=\"AutoMapperValidator.ts\" />\r\n\r\nmodule AutoMapperJs {\r\n    'use strict';\r\n\r\n    // interface shorthands\r\n    type IFluentFunc = ICreateMapFluentFunctions;\r\n    type IDMCO = IMemberConfigurationOptions;\r\n    type ISMCO = ISourceMemberConfigurationOptions;\r\n    type IMC = IMemberCallback;\r\n    type IRC = IResolutionContext;\r\n    type TC = TypeConverter;\r\n\r\n    // method overload shorthands\r\n    type stringOrClass = string | (new () => any);\r\n    type forMemberValueOrFunction = any | ((opts: IDMCO) => any) | ((opts: IDMCO, cb: IMC) => void);\r\n    type forSourceMemberFunction = ((opts: ISMCO) => any) | ((opts: ISMCO, cb: IMC) => void);\r\n    type convertUsingClassOrInstanceOrFunction = ((ctx: IRC) => any) | ((ctx: IRC, callback: IMapCallback) => void) | TC | (new () => TC);\r\n\r\n    export class AutoMapper extends AutoMapperBase {\r\n        private static _instance = new AutoMapper();\r\n\r\n        private _profiles: { [name: string]: IProfile };\r\n        private _mappings: { [key: string]: IMapping };\r\n\r\n        private _asyncMapper: AsyncAutoMapper;\r\n\r\n        public static getInstance(): AutoMapper {\r\n            return AutoMapper._instance;\r\n        }\r\n\r\n        /**\r\n         * This class is intended to be a Singleton. Preferrably use getInstance()\r\n         * function instead of using the constructor directly from code.\r\n         */\r\n        constructor() {\r\n            super();\r\n\r\n            if (AutoMapper._instance) {\r\n                return AutoMapper._instance;\r\n            } else {\r\n                AutoMapper._instance = this;\r\n\r\n                this._profiles = {};\r\n                this._mappings = {};\r\n\r\n                this._asyncMapper = new AsyncAutoMapper();\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Initializes the mapper with the supplied configuration.\r\n         * @param {(config: IConfiguration) => void} configFunction Configuration function to call.\r\n         */\r\n        public initialize(configFunction: (config: IConfiguration) => void): void {\r\n            var that = this;\r\n\r\n            var configuration: IConfiguration = <any>{\r\n                addProfile: (profile: IProfile): void => {\r\n                    profile.configure();\r\n                    that._profiles[profile.profileName] = profile;\r\n                },\r\n                createMap: function (sourceKey: string, destinationKey: string): IFluentFunc {\r\n                    // pass through using arguments to keep createMap's currying support fully functional.\r\n                    return that.createMap.apply(that, arguments);\r\n                }\r\n            };\r\n\r\n            configFunction(configuration);\r\n        }\r\n\r\n        /**\r\n         * Create a mapping profile.\r\n         * @param {string} sourceKey The map source key.\r\n         * @param {string} destinationKey The map destination key.\r\n         * @returns {Core.ICreateMapFluentFunctions}\r\n         */\r\n        public createMap(sourceKeyOrType: string | (new () => any), destinationKeyOrType: string | (new () => any)): IFluentFunc {\r\n            // provide currying support.\r\n            if (arguments.length < 2) {\r\n                return AutoMapperHelper.handleCurrying(this.createMap, arguments, this);\r\n            }\r\n\r\n            var mapping = this.createMappingObjectForGivenKeys(sourceKeyOrType, destinationKeyOrType);\r\n\r\n            return this.createMapGetFluentApiFunctions(mapping);\r\n        }\r\n\r\n        /**\r\n         * Execute a mapping from the source object to a new destination object with explicit mapping configuration and supplied mapping options (using createMap).\r\n         * @param sourceKey Source key, for instance the source type name.\r\n         * @param destinationKey Destination key, for instance the destination type name.\r\n         * @param sourceObject The source object to map.\r\n         * @returns {any} Destination object.\r\n         */\r\n        public map(sourceKeyOrType: stringOrClass, destinationKeyOrType: stringOrClass, sourceObject: any): any {\r\n            if (arguments.length === 3) {\r\n                return this.mapInternal(super.getMapping(this._mappings, sourceKeyOrType, destinationKeyOrType), sourceObject);\r\n            }\r\n\r\n            // provide performance optimized (preloading) currying support.\r\n            if (arguments.length === 2) {\r\n                return (srcObj: any): any => this.mapInternal(super.getMapping(this._mappings, sourceKeyOrType, destinationKeyOrType), srcObj);\r\n            }\r\n\r\n            if (arguments.length === 1) {\r\n                return (dstKey: string | (new () => any), srcObj: any): any => this.map(sourceKeyOrType, dstKey, srcObj);\r\n            }\r\n\r\n            return (srcKey: string | (new () => any), dstKey: string | (new () => any), srcObj: any): any => this.map(srcKey, dstKey, srcObj);\r\n        }\r\n\r\n        /**\r\n         * Execute an asynchronous mapping from the source object to a new destination object with explicit mapping configuration and supplied mapping options (using createMap).\r\n         * @param sourceKey Source key, for instance the source type name.\r\n         * @param destinationKey Destination key, for instance the destination type name.\r\n         * @param sourceObject The source object to map.\r\n         * @param {IMapCallback} callback The callback to call when asynchronous mapping is complete.\r\n         */\r\n        public mapAsync(sourceKeyOrType: string | (new () => any), destinationKeyOrType: string | (new () => any), sourceObject: any, callback: IMapCallback): any {\r\n            switch (arguments.length) {\r\n                case 4:\r\n                    return this._asyncMapper.map(this._mappings, sourceKeyOrType, destinationKeyOrType, sourceObject, callback);\r\n                case 3:\r\n                    return this._asyncMapper.map(this._mappings, sourceKeyOrType, destinationKeyOrType, sourceObject);\r\n                case 2:\r\n                    return this._asyncMapper.map(this._mappings, sourceKeyOrType, destinationKeyOrType);\r\n                case 1:\r\n                    return this._asyncMapper.map(this._mappings, sourceKeyOrType);\r\n                default:\r\n                    throw new Error('The mapAsync function expects between 1 and 4 parameters, you provided ' + arguments.length + '.');\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Validates mapping configuration by dry-running. Since JS does not fully support typing, it only checks if properties match on both\r\n         * sides. The function needs IMapping.sourceTypeClass and IMapping.destinationTypeClass to function.\r\n         * @param {boolean} strictMode Whether or not to fail when properties sourceTypeClass or destinationTypeClass are unavailable.\r\n         */\r\n        public assertConfigurationIsValid(strictMode: boolean = true): void {\r\n            AutoMapperValidator.assertConfigurationIsValid(this._mappings, strictMode);\r\n        }\r\n\r\n        private createMapForAllMembers(mapping: IMapping, fluentFunc: IFluentFunc, func: (dstObj: any, dstProp: string, val: any) => void): IFluentFunc {\r\n            mapping.forAllMemberMappings.push(func);\r\n            return fluentFunc;\r\n        }\r\n\r\n        private createMapIgnoreAllNonExisting(mapping: IMapping, fluentFunc: IFluentFunc): IFluentFunc {\r\n            mapping.ignoreAllNonExisting = true;\r\n            return fluentFunc;\r\n        }\r\n\r\n        private createMapConvertToType(mapping: IMapping, fluentFunc: IFluentFunc, typeClass: new () => any): IFluentFunc {\r\n            if (mapping.destinationTypeClass) {\r\n                throw new Error('Destination type class can only be set once.');\r\n            }\r\n\r\n            mapping.destinationTypeClass = typeClass;\r\n            return fluentFunc;\r\n        }\r\n\r\n        private createMapConvertUsing(mapping: IMapping, tcClassOrFunc: convertUsingClassOrInstanceOrFunction): void {\r\n            var configureSynchronousConverterFunction = (converterFunc: any): void => {\r\n                if (!converterFunc || AutoMapperHelper.getFunctionParameters(converterFunc.toString()).length !== 1) {\r\n                    throw new Error('The function provided does not provide exactly one (resolutionContext) parameter.');\r\n                }\r\n\r\n                mapping.typeConverterFunction = <(resolutionContext: IResolutionContext) => any>converterFunc;\r\n                mapping.mapItemFunction = (m: IMapping, srcObj: any, dstObj: any): any => this.mapItemUsingTypeConverter(m, srcObj, dstObj);\r\n            };\r\n\r\n            try {\r\n                // check if sync: TypeConverter instance\r\n                if (tcClassOrFunc instanceof TypeConverter) {\r\n                    configureSynchronousConverterFunction(tcClassOrFunc.convert);\r\n                    return;\r\n                }\r\n\r\n                var functionParameters = AutoMapperHelper.getFunctionParameters(tcClassOrFunc.toString());\r\n                switch (functionParameters.length) {\r\n                    case 0:\r\n                        // check if sync: TypeConverter class definition\r\n                        var typeConverter: TypeConverter;\r\n                        try {\r\n                            typeConverter = (<TypeConverter>new (<new () => TypeConverter>tcClassOrFunc)());\r\n                        } catch (e) {\r\n                            // Obviously, typeConverterClassOrFunction is not a TypeConverter class definition\r\n                        }\r\n                        if (typeConverter instanceof TypeConverter) {\r\n                            configureSynchronousConverterFunction(typeConverter.convert);\r\n                            return;\r\n                        }\r\n                        break;\r\n                    case 1:\r\n                        // sync: function with resolutionContext parameter\r\n                        configureSynchronousConverterFunction(<(resolutionContext: IResolutionContext) => any>tcClassOrFunc);\r\n                        return;\r\n                    case 2:\r\n                        // check if async: function with resolutionContext and callback parameters\r\n                        this._asyncMapper.createMapConvertUsing(mapping, <(ctx: IResolutionContext, cb: IMapCallback) => void>tcClassOrFunc);\r\n                        return;\r\n                }\r\n\r\n                // okay, just try feeding the function to the configure function anyway...\r\n                configureSynchronousConverterFunction(<any>tcClassOrFunc);\r\n            } catch (e) {\r\n                throw new Error(`The value provided for typeConverterClassOrFunction is invalid. ${e}`);\r\n            }\r\n        }\r\n\r\n        private createMapWithProfile(mapping: IMapping, profileName: string): void {\r\n            // check if given profile exists\r\n            var profile = this._profiles[profileName];\r\n            if (typeof profile === 'undefined' || profile.profileName !== profileName) {\r\n                throw new Error(`Could not find profile with profile name '${profileName}'.`);\r\n            }\r\n\r\n            mapping.profile = profile;\r\n            // merge mappings\r\n            this.createMapWithProfileMergeMappings(mapping, profileName);\r\n        }\r\n\r\n        private createMapWithProfileMergeMappings(mapping: IMapping, profileName: string): void {\r\n            var profileMappingKey = `${profileName}=>${mapping.sourceKey}${profileName}=>${mapping.destinationKey}`;\r\n            var profileMapping: IMapping = this._mappings[profileMappingKey];\r\n            if (!profileMapping) {\r\n                return;\r\n            }\r\n\r\n            // append forAllMemberMappings calls to the original array.\r\n            if (profileMapping.forAllMemberMappings.length > 0) {\r\n                mapping.forAllMemberMappings.push(...profileMapping.forAllMemberMappings);\r\n            }\r\n\r\n            // overwrite original type converter function\r\n            if (profileMapping.typeConverterFunction) {\r\n                mapping.typeConverterFunction = profileMapping.typeConverterFunction;\r\n                mapping.mapItemFunction = profileMapping.mapItemFunction;\r\n            }\r\n\r\n            // overwrite original type converter function\r\n            if (profileMapping.destinationTypeClass) {\r\n                mapping.destinationTypeClass = profileMapping.destinationTypeClass;\r\n            }\r\n\r\n            // walk through all the profile's property mappings\r\n            for (let property of profileMapping.properties) {\r\n                // TODO Awkward way of locating sourceMapping ;) ...\r\n                let sourceMapping = this.getDestinationProperty(property.destinationPropertyName, property).sourceMapping;\r\n                if (!this.mergeSourceProperty(property, mapping.properties, sourceMapping)) {\r\n                    mapping.properties.push(property);\r\n                }\r\n            }\r\n        }\r\n\r\n        private mapInternal(mapping: IMapping, sourceObject: any): any {\r\n            if (sourceObject === null || typeof sourceObject === 'undefined') {\r\n                return sourceObject;\r\n            }\r\n\r\n            if (mapping.async) {\r\n                throw new Error('Impossible to use asynchronous mapping using automapper.map(); use automapper.mapAsync() instead.');\r\n            }\r\n\r\n            if (super.isArray(sourceObject)) {\r\n                return this.mapArray(mapping, sourceObject);\r\n            }\r\n\r\n            return (<IMapItemFunction>mapping.mapItemFunction)(mapping, sourceObject, super.createDestinationObject(mapping.destinationTypeClass));\r\n        }\r\n\r\n        private mapArray(mapping: IMapping, sourceArray: Array<any>): Array<any> {\r\n            var destinationArray = super.handleArray(mapping, sourceArray, (sourceObject: any, destinationObject: any) => {\r\n                (<IMapItemFunction>mapping.mapItemFunction)(mapping, sourceObject, destinationObject);\r\n            });\r\n            return destinationArray;\r\n        }\r\n\r\n        private mapItem(mapping: IMapping, sourceObject: any, destinationObject: any): void {\r\n            destinationObject = super.handleItem(mapping, sourceObject, destinationObject, (propertyName: string) => {\r\n                this.mapProperty(mapping, sourceObject, destinationObject, propertyName);\r\n            });\r\n            return destinationObject;\r\n        }\r\n\r\n        private mapItemUsingTypeConverter(mapping: IMapping, sourceObject: any, destinationObject: any, arrayIndex?: number): void {\r\n            var resolutionContext: IResolutionContext = {\r\n                sourceValue: sourceObject,\r\n                destinationValue: destinationObject\r\n            };\r\n            return (<(ctx: IResolutionContext) => any>mapping.typeConverterFunction)(resolutionContext);\r\n        }\r\n\r\n        private mapProperty(mapping: IMapping, sourceObject: any, destinationObject: any, sourceProperty: string): void {\r\n            super.handleProperty(mapping, sourceObject, sourceProperty, destinationObject, (destinationProperty: IDestinationProperty, options: IDMCO) =>\r\n                this.transform(mapping, sourceObject, destinationProperty, destinationObject, options)\r\n            );\r\n        }\r\n\r\n        private transform(mapping: IMapping, sourceObject: any, destinationProperty: IDestinationProperty, destinationObject: any, options: IDMCO): boolean {\r\n            var childDestinationProperty = destinationProperty.child;\r\n            if (childDestinationProperty) {\r\n                var childDestinationObject = destinationObject[destinationProperty.name];\r\n                if (!childDestinationObject) {\r\n                    // no child source object? create.\r\n                    childDestinationObject = <any>{};\r\n                }\r\n\r\n                // transform child by recursively calling the transform function.\r\n                let transformed = this.transform(mapping, sourceObject, childDestinationProperty, childDestinationObject, options /*, callback*/);\r\n                if (transformed) {\r\n                    // only set child destination object when transformation has been successful.\r\n                    destinationObject[destinationProperty.name] = childDestinationObject;\r\n                }\r\n\r\n                return transformed;\r\n            }\r\n\r\n            if (!super.shouldProcessDestination(destinationProperty, sourceObject)) {\r\n                return false;\r\n            }\r\n\r\n            // actually transform destination property.\r\n            for (let transformation of destinationProperty.transformations) {\r\n                if (!this.processTransformation(destinationProperty, transformation, options)) {\r\n                    return false;\r\n                }\r\n            }\r\n\r\n            super.setPropertyValue(mapping, destinationProperty, destinationObject, options.intermediatePropertyValue);\r\n            return true;\r\n        }\r\n\r\n        private processTransformation(property: IDestinationProperty, transformation: IDestinationTransformation, options: IDMCO): boolean {\r\n            switch (transformation.transformationType) {\r\n                case DestinationTransformationType.Constant:\r\n                    options.intermediatePropertyValue = transformation.constant;\r\n                    return true;\r\n                case DestinationTransformationType.MemberOptions: {\r\n                    let result = transformation.memberConfigurationOptionsFunc(options);\r\n                    if (typeof result !== 'undefined') {\r\n                        options.intermediatePropertyValue = result;\r\n                    } else if (!options.sourceObject) {\r\n                        return false;\r\n                    }\r\n                    return true;\r\n                }\r\n                case DestinationTransformationType.SourceMemberOptions: {\r\n                    let result = transformation.sourceMemberConfigurationOptionsFunc(<ISMCO>options);\r\n                    if (typeof result !== 'undefined') {\r\n                        options.intermediatePropertyValue = result;\r\n                    } else if (!options.sourceObject) {\r\n                        return false;\r\n                    }\r\n\r\n                    return true;\r\n                }\r\n                default:\r\n                    // this.throwMappingException(property, `AutoMapper.handlePropertyMappings: Unexpected transformation type ${transformation.transformationType}`);\r\n                    return false;\r\n            }\r\n        }\r\n\r\n        private createMappingObjectForGivenKeys(srcKeyOrType: string | (new () => any), dstKeyOrType: string | (new () => any)): IMapping {\r\n            var mapping: IMapping = {\r\n                sourceKey: super.getKey(srcKeyOrType),\r\n                destinationKey: super.getKey(dstKeyOrType),\r\n                forAllMemberMappings: new Array<(destinationObject: any, destinationPropertyName: string, value: any) => void>(),\r\n                properties: [],\r\n                typeConverterFunction: undefined,\r\n                mapItemFunction: (m: IMapping, srcObj: any, dstObj: any): any => this.mapItem(m, srcObj, dstObj),\r\n                sourceTypeClass: (typeof srcKeyOrType === 'string' ? undefined : srcKeyOrType),\r\n                destinationTypeClass: (typeof dstKeyOrType === 'string' ? undefined : dstKeyOrType),\r\n                profile: undefined,\r\n                async: false\r\n            };\r\n            this._mappings[mapping.sourceKey + mapping.destinationKey] = mapping;\r\n            return mapping;\r\n        }\r\n\r\n        private createMapGetFluentApiFunctions(mapping: IMapping): IFluentFunc {\r\n            // create a fluent interface / method chaining (e.g. automapper.createMap().forMember().forMember() ...)\r\n            var fluentFunc: IFluentFunc = {\r\n                forMember: (prop: string, valFunc: forMemberValueOrFunction): IFluentFunc =>\r\n                    this.createMapForMember({ mapping: mapping, propertyName: prop, transformation: valFunc, sourceMapping: false, fluentFunctions: fluentFunc }),\r\n                forSourceMember: (prop: string, cfgFunc: ((opts: ISMCO) => any) | ((opts: ISMCO, cb: IMC) => void)): IFluentFunc =>\r\n                    this.createMapForMember({ mapping: mapping, propertyName: prop, transformation: cfgFunc, sourceMapping: true, fluentFunctions: fluentFunc }),\r\n                forAllMembers: (func: (dstObj: any, dstProp: string, value: any) => void): IFluentFunc =>\r\n                    this.createMapForAllMembers(mapping, fluentFunc, func),\r\n                ignoreAllNonExisting: (): IFluentFunc => this.createMapIgnoreAllNonExisting(mapping, fluentFunc),\r\n                convertToType: (type: new () => any): IFluentFunc => this.createMapConvertToType(mapping, fluentFunc, type),\r\n                convertUsing: (tcClassOrFunc: convertUsingClassOrInstanceOrFunction): void =>\r\n                    this.createMapConvertUsing(mapping, tcClassOrFunc),\r\n                withProfile: (profile: string): void => this.createMapWithProfile(mapping, profile)\r\n            };\r\n\r\n            return fluentFunc;\r\n        }\r\n\r\n        private createMapForMember(parameters: ICreateMapForMemberParameters): IFluentFunc {\r\n            var { mapping, propertyName, transformation, sourceMapping, fluentFunctions } = parameters;\r\n\r\n            // extract source/destination property names\r\n            var metadata = AutoMapperHelper.getMappingMetadataFromTransformationFunction(propertyName, transformation, sourceMapping);\r\n            this.validateForMemberParameters(metadata);\r\n\r\n            var { source, destination } = metadata;\r\n\r\n            // create property (regardless of current existance)\r\n            var property = this.createSourceProperty(metadata, null);\r\n\r\n            // merge with existing property or add property\r\n            if (!this.mergeSourceProperty(property, mapping.properties, sourceMapping)) {\r\n                mapping.properties.push(property);\r\n            }\r\n\r\n            if (metadata.async) {\r\n                this._asyncMapper.createMapForMember(mapping, this.findProperty(property.name, mapping.properties));\r\n            }\r\n\r\n            return fluentFunctions;\r\n        }\r\n\r\n        private validateForMemberParameters(metadata: IMemberMappingMetaData): void {\r\n            if (!metadata.sourceMapping) {\r\n                return;\r\n            }\r\n\r\n            // validate forSourceMember parameters\r\n            if (metadata.transformation.transformationType === DestinationTransformationType.Constant) {\r\n                throw new Error('Configuration of forSourceMember has to be a function with one (sync) or two (async) options parameters.');\r\n            }\r\n        }\r\n\r\n        private createSourceProperty(metadata: IMemberMappingMetaData, parent: ISourceProperty): ISourceProperty {\r\n            var level = !parent ? 0 : parent.level + 1;\r\n            var sourceNameParts = metadata.source.split('.');\r\n\r\n            var source = <ISourceProperty>{\r\n                name: sourceNameParts[level],\r\n                sourcePropertyName: metadata.source,\r\n                destinationPropertyName: metadata.destination,\r\n                parent: parent,\r\n                level: level,\r\n                children: <ISourceProperty[]>[],\r\n                destination: <IDestinationProperty>null\r\n            };\r\n\r\n            if ((level + 1) < sourceNameParts.length) {\r\n                // recursively add child source properties ...\r\n                var child = this.createSourceProperty(metadata, source);\r\n                if (child) { // TODO should not be necessary, test thoroughly!\r\n                    source.children.push(child);\r\n                }\r\n                source.destination = null;\r\n            } else {\r\n                // ... or (!) add destination\r\n                source.destination = this.createDestinationProperty(metadata, null);\r\n            }\r\n            return source;\r\n        }\r\n\r\n        private createDestinationProperty(metadata: IMemberMappingMetaData, parent: IDestinationProperty): IDestinationProperty {\r\n            var level = !parent ? 0 : parent.level + 1;\r\n            var destinationNameParts = metadata.destination.split('.');\r\n\r\n            var destination = <IDestinationProperty>{\r\n                name: destinationNameParts[level],\r\n                sourcePropertyName: metadata.source,\r\n                destinationPropertyName: metadata.destination,\r\n                parent: parent,\r\n                level: level,\r\n                child: <IDestinationProperty>null,\r\n                transformations: <IDestinationTransformation[]>[],\r\n                conditionFunction: null,\r\n                ignore: false,\r\n                sourceMapping: false\r\n            };\r\n\r\n            if ((level + 1) < destinationNameParts.length) {\r\n                // recursively add child destination properties\r\n                destination.child = this.createDestinationProperty(metadata, destination);\r\n            } else {\r\n                // add/merge properties\r\n                destination.sourceMapping = metadata.sourceMapping;\r\n                destination.conditionFunction = metadata.condition;\r\n                destination.ignore = metadata.ignore;\r\n                destination.transformations.push(metadata.transformation);\r\n            }\r\n\r\n            return destination;\r\n        }\r\n\r\n        private mergeSourceProperty(property: ISourceProperty, existingProperties: ISourceProperty[], sourceMapping: boolean): boolean {\r\n            // find source property\r\n            var existing = sourceMapping\r\n                ? this.findProperty(property.name, existingProperties)\r\n                : this.matchSourcePropertyByDestination(property, existingProperties);\r\n\r\n            if (!existing) {\r\n                return false;\r\n            }\r\n\r\n            if (property.destination) { // new source is not (further) nested.\r\n                if (existing.children.length > 0) {\r\n                    let existingDestination = this.getDestinationProperty(existing.destinationPropertyName, existing);\r\n\r\n                    // existing is (further) nested => rebase and/or merge\r\n                    if (this.handleMapFromProperties(property, existing)) {\r\n                        // merge and rebase existing destination to current source level\r\n                        if (!this.mergeDestinationProperty(property.destination, existingDestination)) {\r\n                            return false;\r\n                        }\r\n\r\n                        existing.destination = existingDestination;\r\n                        existing.children = [];\r\n                        return true;\r\n                    }\r\n\r\n                    // merge property.destination with existing mapFrom() destination (don't care about nesting depth here)\r\n                    return this.mergeDestinationProperty(property.destination, existingDestination);\r\n                }\r\n\r\n                // both are at same level => simple merge.\r\n                if (!this.mergeDestinationProperty(property.destination, existing.destination)) {\r\n                    return false;\r\n                }\r\n\r\n                this.handleMapFromProperties(property, existing);\r\n                return true;\r\n            }\r\n\r\n            // new source is (further) nested (has children).\r\n            if (existing.children.length > 0) {\r\n                // both have further nesting, delegate merging child(ren) by recursively calling this function.\r\n                for (let child of property.children) {\r\n                    if (!this.mergeSourceProperty(child, existing.children, sourceMapping)) {\r\n                        return false;\r\n                    }\r\n                }\r\n\r\n                if (property.destinationPropertyName !== property.sourcePropertyName) {\r\n                    // this is a mapFrom() registration. It is handled using the nested source properties,\r\n                    // we only are responsible for syncing the name properties.\r\n                    existing.name = property.name;\r\n                    existing.sourcePropertyName = property.sourcePropertyName;\r\n                }\r\n                return true;\r\n            }\r\n\r\n            // existing is not (further) nested. this is always a mapFrom() situation.\r\n            // if (property.sourcePropertyName !== existing.sourcePropertyName) {\r\n                let newDestination = this.getDestinationProperty(existing.destinationPropertyName, property);\r\n\r\n                if (property.destinationPropertyName !== property.sourcePropertyName) {\r\n                    // this is a mapFrom() registration. In that case:\r\n                    // 1) merge destinations, 2) add source child and 3) move destination to (youngest) child\r\n                    // NOTE special mergeDestinationProperty call => we use the new destination as 'target',\r\n                    //      because that will save us trouble overwriting ;)...\r\n                    if (!this.mergeDestinationProperty(existing.destination, newDestination, true)) {\r\n                        return false;\r\n                    }\r\n\r\n                    existing.children = property.children;\r\n                    existing.name = property.name;\r\n                    existing.sourcePropertyName = property.sourcePropertyName;\r\n                    existing.destination = null;\r\n                    // TODO Should never be necessary (test): existing.destinationPropertyName = property.destinationPropertyName;\r\n                    return true;\r\n                }\r\n\r\n                // ... nope, it is a destination which has previously been registered using mapFrom. just merge\r\n                return this.mergeDestinationProperty(newDestination, existing.destination);\r\n            // }\r\n        }\r\n\r\n        /**\r\n         * handle property naming when the current property to merge is a mapFrom property\r\n         */\r\n        private handleMapFromProperties<TProperty extends IProperty>(property: TProperty, existingProperty: TProperty): boolean {\r\n            if (property.destinationPropertyName === property.sourcePropertyName ||\r\n                property.sourcePropertyName === existingProperty.sourcePropertyName) {\r\n                return false;\r\n            }\r\n\r\n            // only overwrite name when a mapFrom situation applies\r\n            existingProperty.name = property.name;\r\n            existingProperty.sourcePropertyName = property.sourcePropertyName;\r\n            // TODO Should never be necessary (test) => existingProperty.destinationPropertyName = property.destinationPropertyName;\r\n\r\n            return true;\r\n        }\r\n\r\n        private getDestinationProperty(destinationPropertyName: string, existingSource: ISourceProperty): IDestinationProperty {\r\n            if (existingSource.destination) {\r\n                return existingSource.destination;\r\n            }\r\n\r\n            for (let child of existingSource.children) {\r\n                var destination = this.getDestinationProperty(destinationPropertyName, child);\r\n                if (destination) {\r\n                    return destination;\r\n                }\r\n            }\r\n\r\n            return null;\r\n        }\r\n\r\n        private mergeDestinationProperty(destination: IDestinationProperty, existingDestination: IDestinationProperty, swapTransformations: boolean = false): boolean {\r\n            if (destination.child) { // destination is (further) nested\r\n                if (existingDestination.child) {\r\n                    // both have further nesting, delegate merging children by recursively calling this function.\r\n                    if (!this.mergeDestinationProperty(destination.child, existingDestination.child, swapTransformations)) {\r\n                        return false;\r\n                    }\r\n\r\n                    this.handleMapFromProperties(destination, existingDestination);\r\n                    return true;\r\n                }\r\n\r\n                // the current destination is not (further) nested. a destination property registration has one of both:\r\n                // a) children or b) transformations. returning false will cause creating a duplicate source property entry instead.\r\n                return false;\r\n            }\r\n\r\n            if (existingDestination.sourceMapping !== destination.sourceMapping &&\r\n                existingDestination.sourcePropertyName !== destination.sourcePropertyName) {\r\n                // unable to perform mapFrom() on a property which is being registered using forSourceMember.\r\n                return false; // TODO: Unpredictable? Idea: throw new Error('Unable to perform mapFrom() on a property which is being registered using forSourceMember.');\r\n            }\r\n\r\n            // merge destination properties\r\n            if (destination.sourceMapping) {\r\n                // only set source mapping when not yet set to true, once source mapped is source mapped forever.\r\n                // TODO Verify edge cases!\r\n                existingDestination.sourceMapping = destination.sourceMapping;\r\n            }\r\n\r\n            if (destination.ignore) {\r\n                // only set ignore when not yet set, once ignored is ignored forever.\r\n                existingDestination.ignore = destination.ignore;\r\n            }\r\n\r\n            if (destination.conditionFunction) {\r\n                // overwrite condition function by the latest one specified.\r\n                existingDestination.conditionFunction = destination.conditionFunction;\r\n            }\r\n\r\n            let transformations: IDestinationTransformation[] = [];\r\n            if (swapTransformations) {\r\n                for (let transformation of destination.transformations) {\r\n                    transformations.push(transformation);\r\n                }\r\n                for (let transformation of existingDestination.transformations) {\r\n                    transformations.push(transformation);\r\n                }\r\n            } else {\r\n                for (let transformation of existingDestination.transformations) {\r\n                    transformations.push(transformation);\r\n                }\r\n                for (let transformation of destination.transformations) {\r\n                    transformations.push(transformation);\r\n                }\r\n            }\r\n            existingDestination.transformations = transformations;\r\n\r\n            this.handleMapFromProperties(destination, existingDestination);\r\n            return true;\r\n        }\r\n\r\n        private matchSourcePropertyByDestination(source: ISourceProperty, properties: ISourceProperty[]): ISourceProperty {\r\n            if (!properties) {\r\n                return null;\r\n            }\r\n\r\n            for (let property of properties) {\r\n                if (property.destinationPropertyName === source.destinationPropertyName) {\r\n                    return property;\r\n                }\r\n            }\r\n\r\n            return null;\r\n        }\r\n\r\n        private findProperty<TProperty extends IProperty>(name: string, properties: TProperty[]): TProperty {\r\n            if (!properties) {\r\n                return null;\r\n            }\r\n\r\n            for (var property of properties) {\r\n                if (property.name === name) {\r\n                    return property;\r\n                }\r\n            }\r\n\r\n            return null;\r\n        }\r\n\r\n    }\r\n}\r\n\r\n// Add AutoMapper to the application's global scope. Of course, you could still use Core.AutoMapper.getInstance() as well.\r\nvar automapper: AutoMapperJs.AutoMapper = ((app: any): AutoMapperJs.AutoMapper => {\r\n    app.automapper = AutoMapperJs.AutoMapper.getInstance();\r\n    return app.automapper;\r\n})(this);\r\n"]}