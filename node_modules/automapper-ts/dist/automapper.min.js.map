{"version":3,"sources":["AutoMapperHelper.js","AutoMapperValidator.js","AutoMapperEnumerations.js","AutoMapperBase.js","AsyncAutoMapper.js","AutoMapper.js","Profile.js","TypeConverter.js","naming-conventions/CamelCaseNamingConvention.js","naming-conventions/PascalCaseNamingConvention.js"],"names":["AutoMapperJs","AutoMapperHelper","getClassName","classType","name","constructor","className","toString","matchParts","match","length","str","regExpMatchArray","charAt","Error","getFunctionParameters","functionStr","stripComments","argumentNames","functionString","replace","functionParameterNames","slice","indexOf","Array","handleCurrying","func","args","closure","accumulator","moreArgs","alreadyProvidedArgs","stillToCome","previousAlreadyProvidedArgs","previousStillToCome","i","functionCallResult","apply","arguments","argumentsStillToCome","prototype","getMappingMetadataFromTransformationFunction","destination","sourceMapping","source","transformation","getDestinationTransformation","condition","ignore","async","parameterNames","optsParamName","getMapFromString","metadata","getIgnoreFromString","getFunctionCallIndex","getConditionFromFunction","isFunction","transformationType","DestinationTransformationType","Constant","constant","AsyncSourceMemberOptions","asyncSourceMemberConfigurationOptionsFunc","SourceMemberOptions","sourceMemberConfigurationOptionsFunc","AsyncMemberOptions","asyncMemberConfigurationOptionsFunc","MemberOptions","memberConfigurationOptionsFunc","optionsParameterName","indexOfIgnore","indexOfMapFromStart","indexOfMapFromEnd","ignoreString","substring","trim","defaultValue","indexOfMapFrom","mapFromString","functionToLookFor","indexOfFunctionCall","sourceProperty","sourceObject","configFuncOptions","predicate","mapFrom","sourcePropertyName","intermediatePropertyValue","exc","AutoMapperValidator","assertConfigurationIsValid","mappings","strictMode","key","hasOwnProperty","assertMappingConfiguration","mapping","mappingKey","sourceKey","destinationKey","sourceType","sourceTypeClass","destinationType","destinationTypeClass","sourceClassName","undefined","destinationClassName","tryHandle","errorMessage","validatedMembers","srcObj","dstObj","_i","_a","properties","property","validatePropertyMapping","push","srcMember","validateProperty","dstMember","propertyMapping","member","destinationProperty","getDestinationProperty","destinationPropertyName","validateSourcePropertyMapping","validateDestinationPropertyMapping","ropertyMapping","existingSource","children","child","this","AutoMapperBase","getMapping","srcKey","getKey","dstKey","keyStringOrType","isArray","handleArray","sourceArray","itemFunc","arrayLength","destinationArray","index","destinationObject","createDestinationObject","handleItem","propertyFunction","atLeastOnePropertyMapped","handleProperty","transformFunction","autoMappingCallbackFunction","propertyMappings","getPropertyMappings","propertyMappings_1","processMappedProperty","handlePropertyWithAutoMapping","setPropertyValue","destinationPropertyValue","forAllMemberMappings","forAllMemberMapping","setPropertyValueByName","shouldProcessDestination","conditionFunction","ignoreAllNonExisting","Object","keys","objectValue","isNestedObject","createMap","convertToType","map","getDestinationPropertyName","profile","getDestinationPropertyValue","sourcePropertyNameParts","split","sourceMemberNamingConvention","splittingExpression","splice","destinationMemberNamingConvention","transformPropertyName","error","result","properties_1","childSourceObject","createMemberConfigurationOptions","__extends","extendStatics","setPrototypeOf","__proto__","d","b","p","__","create","AsyncAutoMapper","_super","_this","call","asyncInstance","sourceKeyOrType","destinationKeyOrType","createMapForMember","mapItemFunction","m","cb","mapItem","createMapConvertUsing","converterFunction","typeConverterFunction","mapItemUsingTypeConverter","callback","mapWithMapping","mapArray","callbacksToGo","waitForCallbackToSend","setTimeout","resolutionContext","sourceValue","destinationValue","mapProperty","options","transform","success","childDestinationProperty","childDestinationObject","callbackValue","processTransformations","transformations","processTransformation","AutoMapper","_instance","_profiles","_mappings","_asyncMapper","getInstance","initialize","configFunction","that","addProfile","configure","profileName","createMappingObjectForGivenKeys","createMapGetFluentApiFunctions","mapInternal","mapAsync","createMapForAllMembers","fluentFunc","createMapIgnoreAllNonExisting","createMapConvertToType","typeClass","tcClassOrFunc","configureSynchronousConverterFunction","converterFunc","TypeConverter","convert","typeConverter","e","createMapWithProfile","createMapWithProfileMergeMappings","profileMappingKey","profileMapping","_b","mergeSourceProperty","propertyName","arrayIndex","transformed","srcKeyOrType","dstKeyOrType","forMember","prop","valFunc","fluentFunctions","forSourceMember","cfgFunc","forAllMembers","type","convertUsing","withProfile","parameters","validateForMemberParameters","createSourceProperty","findProperty","parent","level","sourceNameParts","createDestinationProperty","destinationNameParts","existingProperties","existing","matchSourcePropertyByDestination","existingDestination","handleMapFromProperties","mergeDestinationProperty","newDestination","existingProperty","swapTransformations","_c","_d","_e","_f","_g","properties_2","automapper","app","Profile","argsCopy","CamelCaseNamingConvention","separatorCharacter","toLowerCase","substr","toUpperCase","PascalCaseNamingConvention"],"mappings":"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","file":"automapper.min.js","sourcesContent":["/// <reference path=\"AutoMapperEnumerations.ts\" />\nvar AutoMapperJs;\n(function (AutoMapperJs) {\n    'use strict';\n    /**\n     * AutoMapper helper functions\n     */\n    var AutoMapperHelper = (function () {\n        function AutoMapperHelper() {\n        }\n        AutoMapperHelper.getClassName = function (classType) {\n            if (classType && classType.name) {\n                return classType.name;\n            }\n            // source: http://stackoverflow.com/a/13914278/702357\n            if (classType && classType.constructor) {\n                var className = classType.toString();\n                if (className) {\n                    // classType.toString() is \"function classType (...) { ... }\"\n                    var matchParts = className.match(/function\\s*(\\w+)/);\n                    if (matchParts && matchParts.length === 2) {\n                        return matchParts[1];\n                    }\n                }\n                // for browsers which have name property in the constructor\n                // of the object, such as chrome\n                if (classType.constructor.name) {\n                    return classType.constructor.name;\n                }\n                if (classType.constructor.toString()) {\n                    var str = classType.constructor.toString();\n                    var regExpMatchArray = void 0;\n                    if (str.charAt(0) === '[') {\n                        // executed if the return of object.constructor.toString() is \"[object objectClass]\"\n                        regExpMatchArray = str.match(/\\[\\w+\\s*(\\w+)\\]/);\n                    }\n                    else {\n                        // executed if the return of object.constructor.toString() is \"function objectClass () {}\"\n                        // (IE and Firefox)\n                        regExpMatchArray = str.match(/function\\s*(\\w+)/);\n                    }\n                    if (regExpMatchArray && regExpMatchArray.length === 2) {\n                        return regExpMatchArray[1];\n                    }\n                }\n            }\n            throw new Error(\"Unable to extract class name from type '\" + classType + \"'\");\n        };\n        AutoMapperHelper.getFunctionParameters = function (functionStr) {\n            var stripComments = /((\\/\\/.*$)|(\\/\\*[\\s\\S]*?\\*\\/))/mg;\n            var argumentNames = /([^\\s,]+)/g;\n            var functionString = functionStr.replace(stripComments, '');\n            var functionParameterNames = functionString.slice(functionString.indexOf('(') + 1, functionString.indexOf(')')).match(argumentNames);\n            if (functionParameterNames === null) {\n                functionParameterNames = new Array();\n            }\n            return functionParameterNames;\n        };\n        AutoMapperHelper.handleCurrying = function (func, args, closure) {\n            var argumentsStillToCome = func.length - args.length;\n            // saved accumulator array\n            // NOTE BL this does not deep copy array objects, only the array itself; should side effects occur, please report (or refactor).\n            var argumentsCopy = Array.prototype.slice.apply(args);\n            function accumulator(moreArgs, alreadyProvidedArgs, stillToCome) {\n                var previousAlreadyProvidedArgs = alreadyProvidedArgs.slice(0); // to reset\n                var previousStillToCome = stillToCome; // to reset\n                for (var i = 0; i < moreArgs.length; i++, stillToCome--) {\n                    alreadyProvidedArgs[alreadyProvidedArgs.length] = moreArgs[i];\n                }\n                if (stillToCome - moreArgs.length <= 0) {\n                    var functionCallResult = func.apply(closure, alreadyProvidedArgs);\n                    // reset vars, so curried function can be applied to new params.\n                    alreadyProvidedArgs = previousAlreadyProvidedArgs;\n                    stillToCome = previousStillToCome;\n                    return functionCallResult;\n                }\n                else {\n                    return function () {\n                        // arguments are params, so closure bussiness is avoided.\n                        return accumulator(arguments, alreadyProvidedArgs.slice(0), stillToCome);\n                    };\n                }\n            }\n            return accumulator([], argumentsCopy, argumentsStillToCome);\n        };\n        AutoMapperHelper.getMappingMetadataFromTransformationFunction = function (destination, func, sourceMapping) {\n            if (typeof func !== 'function') {\n                return {\n                    destination: destination,\n                    source: destination,\n                    transformation: AutoMapperHelper.getDestinationTransformation(func, false, sourceMapping, false),\n                    sourceMapping: sourceMapping,\n                    condition: null,\n                    ignore: false,\n                    async: false\n                };\n            }\n            var functionStr = func.toString();\n            var parameterNames = AutoMapperHelper.getFunctionParameters(functionStr);\n            var optsParamName = parameterNames.length >= 1 ? parameterNames[0] : '';\n            var source = sourceMapping\n                ? destination\n                : AutoMapperHelper.getMapFromString(functionStr, destination, optsParamName);\n            var metadata = {\n                destination: destination,\n                source: source,\n                transformation: AutoMapperHelper.getDestinationTransformation(func, true, sourceMapping, parameterNames.length === 2),\n                sourceMapping: sourceMapping,\n                condition: null,\n                ignore: AutoMapperHelper.getIgnoreFromString(functionStr, destination),\n                async: parameterNames.length === 2\n            };\n            // calling the member options function when used asynchronous would be too 'dangerous'.\n            if (!metadata.async && AutoMapperHelper.getFunctionCallIndex(functionStr, 'condition', optsParamName) >= 0) {\n                metadata.condition = AutoMapperHelper.getConditionFromFunction(func, source);\n            }\n            return metadata;\n        };\n        AutoMapperHelper.getDestinationTransformation = function (func, isFunction, sourceMapping, async) {\n            if (!isFunction) {\n                return {\n                    transformationType: AutoMapperJs.DestinationTransformationType.Constant,\n                    constant: func\n                };\n            }\n            var transformation;\n            if (sourceMapping) {\n                if (async) {\n                    transformation = {\n                        transformationType: AutoMapperJs.DestinationTransformationType.AsyncSourceMemberOptions,\n                        asyncSourceMemberConfigurationOptionsFunc: func\n                    };\n                }\n                else {\n                    transformation = {\n                        transformationType: AutoMapperJs.DestinationTransformationType.SourceMemberOptions,\n                        sourceMemberConfigurationOptionsFunc: func\n                    };\n                }\n            }\n            else {\n                if (async) {\n                    transformation = {\n                        transformationType: AutoMapperJs.DestinationTransformationType.AsyncMemberOptions,\n                        asyncMemberConfigurationOptionsFunc: func\n                    };\n                }\n                else {\n                    transformation = {\n                        transformationType: AutoMapperJs.DestinationTransformationType.MemberOptions,\n                        memberConfigurationOptionsFunc: func\n                    };\n                }\n            }\n            return transformation;\n        };\n        AutoMapperHelper.getIgnoreFromString = function (functionString, optionsParameterName) {\n            var indexOfIgnore = AutoMapperHelper.getFunctionCallIndex(functionString, 'ignore', optionsParameterName);\n            if (indexOfIgnore < 0) {\n                return false;\n            }\n            var indexOfMapFromStart = functionString.indexOf('(', indexOfIgnore) + 1;\n            var indexOfMapFromEnd = functionString.indexOf(')', indexOfMapFromStart);\n            if (indexOfMapFromStart < 0 || indexOfMapFromEnd < 0) {\n                return false;\n            }\n            var ignoreString = functionString.substring(indexOfMapFromStart, indexOfMapFromEnd).replace(/\\r/g, '').replace(/\\n/g, '').trim();\n            return ignoreString === null || ignoreString === ''\n                ? true // <optionsParameterName>.ignore()\n                : false; // <optionsParameterName>.ignore(<ignoreString> -> unexpected content)\n        };\n        AutoMapperHelper.getMapFromString = function (functionString, defaultValue, optionsParameterName) {\n            var indexOfMapFrom = AutoMapperHelper.getFunctionCallIndex(functionString, 'mapFrom', optionsParameterName);\n            if (indexOfMapFrom < 0) {\n                return defaultValue;\n            }\n            var indexOfMapFromStart = functionString.indexOf('(', indexOfMapFrom) + 1;\n            var indexOfMapFromEnd = functionString.indexOf(')', indexOfMapFromStart);\n            if (indexOfMapFromStart < 0 || indexOfMapFromEnd < 0) {\n                return defaultValue;\n            }\n            var mapFromString = functionString.substring(indexOfMapFromStart, indexOfMapFromEnd).replace(/'/g, '').replace(/\"/g, '').trim();\n            return mapFromString === null || mapFromString === ''\n                ? defaultValue\n                : mapFromString;\n        };\n        AutoMapperHelper.getFunctionCallIndex = function (functionString, functionToLookFor, optionsParameterName) {\n            var indexOfFunctionCall = functionString.indexOf(optionsParameterName + '.' + functionToLookFor);\n            if (indexOfFunctionCall < 0) {\n                indexOfFunctionCall = functionString.indexOf('.' + functionToLookFor);\n            }\n            return indexOfFunctionCall;\n        };\n        AutoMapperHelper.getConditionFromFunction = function (func, sourceProperty) {\n            // Since we are calling the valueOrFunction function to determine whether to ignore or map from another property, we\n            // want to prevent the call to be error prone when the end user uses the '(opts)=> opts.sourceObject.sourcePropertyName'\n            // syntax. We don't actually have a source object when creating a mapping; therefore, we 'stub' a source object for the\n            // function call.\n            var sourceObject = {};\n            sourceObject[sourceProperty] = {};\n            var condition;\n            // calling the function will result in calling our stubbed ignore() and mapFrom() functions if used inside the function.\n            var configFuncOptions = {\n                ignore: function () {\n                    // do nothing\n                },\n                condition: function (predicate) {\n                    condition = predicate;\n                },\n                mapFrom: function (sourcePropertyName) {\n                    // do nothing\n                },\n                sourceObject: sourceObject,\n                sourcePropertyName: sourceProperty,\n                intermediatePropertyValue: {}\n            };\n            try {\n                func(configFuncOptions);\n            }\n            catch (exc) {\n                // do not handle by default.\n            }\n            return condition;\n        };\n        return AutoMapperHelper;\n    }());\n    AutoMapperJs.AutoMapperHelper = AutoMapperHelper;\n})(AutoMapperJs || (AutoMapperJs = {}));\n\n//# sourceMappingURL=AutoMapperHelper.js.map\n","/// <reference path=\"../../dist/automapper-interfaces.d.ts\" />\n/// <reference path=\"AutoMapperHelper.ts\" />\nvar AutoMapperJs;\n(function (AutoMapperJs) {\n    'use strict';\n    /**\n     * AutoMapper configuration validator.\n     */\n    var AutoMapperValidator = (function () {\n        function AutoMapperValidator() {\n        }\n        /**\n         * Validates mapping configuration by dry-running. Since JS does not\n         * fully support typing, it only checks if properties match on both\n         * sides. The function needs IMapping.sourceTypeClass and\n         * IMapping.destinationTypeClass to function.\n         * @param {boolean} strictMode Whether or not to fail when properties\n         *                             sourceTypeClass or destinationTypeClass\n         *                             are unavailable.\n         */\n        AutoMapperValidator.assertConfigurationIsValid = function (mappings, strictMode) {\n            for (var key in mappings) {\n                if (!mappings.hasOwnProperty(key)) {\n                    continue;\n                }\n                AutoMapperValidator.assertMappingConfiguration(mappings[key], strictMode);\n            }\n        };\n        AutoMapperValidator.assertMappingConfiguration = function (mapping, strictMode) {\n            var mappingKey = mapping.sourceKey + \"=>\" + mapping.destinationKey;\n            var sourceType = mapping.sourceTypeClass;\n            var destinationType = mapping.destinationTypeClass;\n            var sourceClassName = sourceType ? AutoMapperJs.AutoMapperHelper.getClassName(sourceType) : undefined;\n            var destinationClassName = destinationType ? AutoMapperJs.AutoMapperHelper.getClassName(destinationType) : undefined;\n            if (!sourceType || !destinationType) {\n                if (strictMode === false) {\n                    return;\n                }\n                throw new Error(\"Mapping '\" + mappingKey + \"' cannot be validated, since mapping.sourceType or mapping.destinationType are unspecified.\");\n            }\n            var tryHandle = function (errorMessage) {\n                if (errorMessage) {\n                    throw new Error(\"Mapping '\" + mappingKey + \"' is invalid: \" + errorMessage + \" (source: '\" + sourceClassName + \"', destination: '\" + destinationClassName + \"').\");\n                }\n            };\n            var validatedMembers = new Array();\n            var srcObj = new sourceType();\n            var dstObj = new destinationType();\n            // walk member mappings\n            for (var _i = 0, _a = mapping.properties; _i < _a.length; _i++) {\n                var property = _a[_i];\n                tryHandle(AutoMapperValidator.validatePropertyMapping(property, property.name, srcObj, dstObj));\n                validatedMembers.push(property.name);\n            }\n            // walk source members\n            for (var srcMember in srcObj) {\n                if (!srcObj.hasOwnProperty(srcMember)) {\n                    continue;\n                }\n                if (validatedMembers.indexOf(srcMember) >= 0) {\n                    // already validated\n                    continue;\n                }\n                tryHandle(AutoMapperValidator.validateProperty(srcMember, dstObj));\n                validatedMembers.push(srcMember);\n            }\n            // walk destination members\n            for (var dstMember in dstObj) {\n                if (!dstObj.hasOwnProperty(dstMember)) {\n                    continue;\n                }\n                if (validatedMembers.indexOf(dstMember) >= 0) {\n                    // already validated\n                    continue;\n                }\n                tryHandle(\"Destination member '\" + dstMember + \"' does not exist on source type\");\n            }\n            // /* tslint:disable */\n            // console.error(key);\n            // /* tslint:enable */\n        };\n        AutoMapperValidator.validatePropertyMapping = function (propertyMapping, member, srcObj, dstObj) {\n            // awkward way of locating sourceMapping ;) ...\n            var destinationProperty = AutoMapperValidator.getDestinationProperty(propertyMapping.destinationPropertyName, propertyMapping);\n            return destinationProperty.sourceMapping\n                ? AutoMapperValidator.validateSourcePropertyMapping(propertyMapping, destinationProperty, member, srcObj, dstObj)\n                : AutoMapperValidator.validateDestinationPropertyMapping(propertyMapping, destinationProperty, member, srcObj, dstObj);\n        };\n        AutoMapperValidator.validateSourcePropertyMapping = function (ropertyMapping, destinationProperty, member, srcObj, dstObj) {\n            // a member for which configuration is provided, should exist.\n            if (!srcObj.hasOwnProperty(member)) {\n                return \"Source member '\" + member + \"' is configured, but does not exist on source type\";\n            }\n            // an ignored source member should not exist on the destination type.\n            if (destinationProperty.ignore) {\n                if (dstObj.hasOwnProperty(member)) {\n                    return \"Source member '\" + member + \"' is ignored, but does exist on destination type\";\n                }\n                return undefined;\n            }\n            // a mapped source member should exist on the destination type.\n            if (!dstObj.hasOwnProperty(member)) {\n                return \"Source member '\" + member + \"' is configured to be mapped, but does not exist on destination type\";\n            }\n            //var dstMember = propertyMapping.destinationProperty;\n            return undefined;\n        };\n        AutoMapperValidator.validateDestinationPropertyMapping = function (propertyMapping, destinationProperty, member, srcObj, dstObj) {\n            // a member for which configuration is provided, should exist.\n            if (!dstObj.hasOwnProperty(destinationProperty.name)) {\n                return \"Destination member '\" + destinationProperty.destinationPropertyName + \"' is configured, but does not exist on destination type\";\n            }\n            // an ignored destination member should not exist on the source type.\n            if (destinationProperty.ignore) {\n                if (srcObj.hasOwnProperty(member)) {\n                    return \"Destination member '\" + member + \"' is ignored, but does exist on source type\";\n                }\n                return undefined;\n            }\n            // a mapped destination member should exist on the source type.\n            if (!srcObj.hasOwnProperty(member)) {\n                return \"Destination member '\" + member + \"' is configured to be mapped, but does not exist on source type\";\n            }\n            //var dstMember = propertyMapping.destinationProperty;\n            return undefined;\n        };\n        AutoMapperValidator.validateProperty = function (srcMember, dstObj) {\n            if (!dstObj.hasOwnProperty(srcMember)) {\n                return \"Source member '\" + srcMember + \"' is configured to be mapped, but does not exist on destination type\";\n            }\n            return undefined;\n        };\n        AutoMapperValidator.getDestinationProperty = function (destinationPropertyName, existingSource) {\n            if (existingSource.destination) {\n                return existingSource.destination;\n            }\n            if (existingSource.children) {\n                for (var _i = 0, _a = existingSource.children; _i < _a.length; _i++) {\n                    var child = _a[_i];\n                    var destination = this.getDestinationProperty(destinationPropertyName, child);\n                    if (destination) {\n                        return destination;\n                    }\n                }\n            }\n            return null;\n        };\n        return AutoMapperValidator;\n    }());\n    AutoMapperJs.AutoMapperValidator = AutoMapperValidator;\n})(AutoMapperJs || (AutoMapperJs = {}));\n\n//# sourceMappingURL=AutoMapperValidator.js.map\n","var AutoMapperJs;\n(function (AutoMapperJs) {\n    'use strict';\n    var DestinationTransformationType;\n    (function (DestinationTransformationType) {\n        DestinationTransformationType[DestinationTransformationType[\"Constant\"] = 1] = \"Constant\";\n        DestinationTransformationType[DestinationTransformationType[\"MemberOptions\"] = 2] = \"MemberOptions\";\n        DestinationTransformationType[DestinationTransformationType[\"AsyncMemberOptions\"] = 4] = \"AsyncMemberOptions\";\n        DestinationTransformationType[DestinationTransformationType[\"SourceMemberOptions\"] = 8] = \"SourceMemberOptions\";\n        DestinationTransformationType[DestinationTransformationType[\"AsyncSourceMemberOptions\"] = 16] = \"AsyncSourceMemberOptions\";\n    })(DestinationTransformationType = AutoMapperJs.DestinationTransformationType || (AutoMapperJs.DestinationTransformationType = {}));\n})(AutoMapperJs || (AutoMapperJs = {}));\n\n//# sourceMappingURL=AutoMapperEnumerations.js.map\n","/// <reference path=\"../../dist/automapper-interfaces.d.ts\" />\n/// <reference path=\"TypeConverter.ts\" />\n/// <reference path=\"AutoMapperHelper.ts\" />\n/// <reference path=\"AutoMapperValidator.ts\" />\nvar AutoMapperJs;\n(function (AutoMapperJs) {\n    'use strict';\n    /**\n     * AutoMapper implementation, for both creating maps and performing maps. Comparable usage and functionality to the original\n     * .NET AutoMapper library is the pursuit of this implementation.\n     */\n    var AutoMapperBase = (function () {\n        function AutoMapperBase() {\n        }\n        AutoMapperBase.prototype.getMapping = function (mappings, sourceKey, destinationKey) {\n            var srcKey = this.getKey(sourceKey);\n            var dstKey = this.getKey(destinationKey);\n            var mapping = mappings[srcKey + dstKey];\n            if (!mapping) {\n                throw new Error(\"Could not find map object with a source of \" + srcKey + \" and a destination of \" + dstKey);\n            }\n            return mapping;\n        };\n        AutoMapperBase.prototype.getKey = function (keyStringOrType) {\n            if (typeof keyStringOrType === 'string') {\n                return keyStringOrType;\n            }\n            else {\n                return AutoMapperJs.AutoMapperHelper.getClassName(keyStringOrType);\n            }\n        };\n        AutoMapperBase.prototype.isArray = function (sourceObject) {\n            return sourceObject instanceof Array;\n        };\n        AutoMapperBase.prototype.handleArray = function (mapping, sourceArray, itemFunc) {\n            var arrayLength = sourceArray.length;\n            var destinationArray = new Array(sourceArray.length);\n            for (var index = 0; index < arrayLength; index++) {\n                var sourceObject = sourceArray[index];\n                var destinationObject = void 0;\n                if (sourceObject === null || sourceObject === undefined) {\n                    destinationObject = sourceObject;\n                }\n                else {\n                    destinationObject = this.createDestinationObject(mapping.destinationTypeClass);\n                    itemFunc(sourceObject, destinationObject);\n                }\n                destinationArray[index] = destinationObject;\n            }\n            return destinationArray;\n        };\n        AutoMapperBase.prototype.handleItem = function (mapping, sourceObject, destinationObject, propertyFunction) {\n            // var sourceProperties: string[] = [];\n            var atLeastOnePropertyMapped = false;\n            // handle mapped properties ...\n            for (var _i = 0, _a = mapping.properties; _i < _a.length; _i++) {\n                var property = _a[_i];\n                // sourceProperties.push(property.name);\n                atLeastOnePropertyMapped = true;\n                propertyFunction(property.name);\n            }\n            // .. and, after that, handle unmapped properties\n            for (var sourcePropertyName in sourceObject) {\n                if (!sourceObject.hasOwnProperty(sourcePropertyName)) {\n                    continue;\n                }\n                atLeastOnePropertyMapped = true;\n                propertyFunction(sourcePropertyName);\n            }\n            // return null/undefined sourceObject if no properties added\n            if (!atLeastOnePropertyMapped && (sourceObject === null || sourceObject === undefined)) {\n                return sourceObject;\n            }\n            return destinationObject;\n        };\n        AutoMapperBase.prototype.handleProperty = function (mapping, sourceObject, sourcePropertyName, destinationObject, transformFunction, autoMappingCallbackFunction) {\n            // TODO Property mappings are already located before\n            // TODO handleProperty seems only to be called when processing a mapped property.\n            var propertyMappings = this.getPropertyMappings(mapping.properties, sourcePropertyName);\n            if (propertyMappings.length > 0) {\n                for (var _i = 0, propertyMappings_1 = propertyMappings; _i < propertyMappings_1.length; _i++) {\n                    var propertyMapping = propertyMappings_1[_i];\n                    this.processMappedProperty(mapping, propertyMapping, sourceObject, sourcePropertyName, transformFunction);\n                }\n            }\n            else {\n                this.handlePropertyWithAutoMapping(mapping, sourceObject, sourcePropertyName, destinationObject, autoMappingCallbackFunction);\n            }\n        };\n        AutoMapperBase.prototype.setPropertyValue = function (mapping, destinationProperty, destinationObject, destinationPropertyValue) {\n            if (mapping.forAllMemberMappings.length > 0) {\n                for (var _i = 0, _a = mapping.forAllMemberMappings; _i < _a.length; _i++) {\n                    var forAllMemberMapping = _a[_i];\n                    forAllMemberMapping(destinationObject, destinationProperty.name, destinationPropertyValue);\n                }\n            }\n            else {\n                destinationObject[destinationProperty.name] = destinationPropertyValue;\n            }\n        };\n        AutoMapperBase.prototype.setPropertyValueByName = function (mapping, destinationObject, destinationProperty, destinationPropertyValue) {\n            if (mapping.forAllMemberMappings.length > 0) {\n                for (var _i = 0, _a = mapping.forAllMemberMappings; _i < _a.length; _i++) {\n                    var forAllMemberMapping = _a[_i];\n                    forAllMemberMapping(destinationObject, destinationProperty, destinationPropertyValue);\n                }\n            }\n            else {\n                destinationObject[destinationProperty] = destinationPropertyValue;\n            }\n        };\n        AutoMapperBase.prototype.createDestinationObject = function (destinationType) {\n            // create empty destination object.\n            return destinationType\n                ? new destinationType()\n                : {};\n        };\n        AutoMapperBase.prototype.shouldProcessDestination = function (destination, sourceObject) {\n            if (destination.ignore) {\n                // ignore ignored properties\n                return false;\n            }\n            if (destination.conditionFunction) {\n                // check for condition function, and, if there is ...\n                if (destination.conditionFunction(sourceObject) === false) {\n                    // ... return when the condition is not met.\n                    return false;\n                }\n            }\n            return true;\n        };\n        // protected throwMappingException(propertyMapping: IProperty, message: string): void {\n        //     throw new Error(`Cannot map '${propertyMapping.sourcePropertyName}' to '${propertyMapping.destinationPropertyName}' => ${message}`);\n        // }\n        AutoMapperBase.prototype.handlePropertyWithAutoMapping = function (mapping, sourceObject, sourcePropertyName, destinationObject, autoMappingCallbackFunction) {\n            // no forMember mapping exists, auto map properties, except for the situation where ignoreAllNonExisting is specified.\n            if (mapping.ignoreAllNonExisting) {\n                return;\n            }\n            if (mapping.destinationTypeClass && Object.keys(destinationObject).indexOf(sourcePropertyName) < 0) {\n                return;\n            }\n            var objectValue = null;\n            var isNestedObject = false;\n            if (typeof destinationObject[sourcePropertyName] === 'object' && destinationObject[sourcePropertyName]) {\n                isNestedObject = (destinationObject[sourcePropertyName].constructor.name !== 'Object');\n                if (isNestedObject) {\n                    this\n                        .createMap(sourceObject[sourcePropertyName].constructor.name, destinationObject[sourcePropertyName].constructor.name)\n                        .convertToType(destinationObject[sourcePropertyName].constructor);\n                    objectValue = this.map(sourceObject[sourcePropertyName].constructor.name, destinationObject[sourcePropertyName].constructor.name, sourceObject[sourcePropertyName]);\n                }\n            }\n            // use profile mapping when specified; otherwise, specify source property name as destination property name.\n            var destinationPropertyName = this.getDestinationPropertyName(mapping.profile, sourcePropertyName);\n            var destinationPropertyValue = this.getDestinationPropertyValue(sourceObject, sourcePropertyName, objectValue, isNestedObject);\n            this.setPropertyValueByName(mapping, destinationObject, destinationPropertyName, destinationPropertyValue);\n            if (autoMappingCallbackFunction) {\n                autoMappingCallbackFunction(destinationPropertyValue);\n            }\n        };\n        AutoMapperBase.prototype.getDestinationPropertyValue = function (sourceObject, sourcePropertyName, objectValue, isNestedObject) {\n            if (isNestedObject) {\n                return objectValue;\n            }\n            return sourceObject ? sourceObject[sourcePropertyName] : null;\n        };\n        AutoMapperBase.prototype.getDestinationPropertyName = function (profile, sourcePropertyName) {\n            if (!profile) {\n                return sourcePropertyName;\n            }\n            // TODO BL no support yet for INamingConvention.splittingCharacter\n            try {\n                // First, split the source property name based on the splitting expression.\n                // TODO BL Caching of RegExp splitting!\n                var sourcePropertyNameParts = sourcePropertyName.split(profile.sourceMemberNamingConvention.splittingExpression);\n                // NOTE BL For some reason, splitting by (my ;)) RegExp results in empty strings in the array; remove them.\n                for (var index = sourcePropertyNameParts.length - 1; index >= 0; index--) {\n                    if (sourcePropertyNameParts[index] === '') {\n                        sourcePropertyNameParts.splice(index, 1);\n                    }\n                }\n                return profile.destinationMemberNamingConvention.transformPropertyName(sourcePropertyNameParts);\n            }\n            catch (error) {\n                return sourcePropertyName;\n            }\n        };\n        AutoMapperBase.prototype.getPropertyMappings = function (properties, sourcePropertyName) {\n            var result = [];\n            for (var _i = 0, properties_1 = properties; _i < properties_1.length; _i++) {\n                var property = properties_1[_i];\n                if (property.name === sourcePropertyName) {\n                    result.push(property);\n                }\n            }\n            return result;\n        };\n        AutoMapperBase.prototype.processMappedProperty = function (mapping, propertyMapping, sourceObject, sourcePropertyName, transformFunction) {\n            if (propertyMapping.children && propertyMapping.children.length > 0) {\n                // always pass child source object, even if source object does not exist =>\n                // constant transformations should always pass.\n                var childSourceObject = sourceObject ? sourceObject[propertyMapping.name] : null;\n                for (var _i = 0, _a = propertyMapping.children; _i < _a.length; _i++) {\n                    var child = _a[_i];\n                    this.processMappedProperty(mapping, child, childSourceObject, child.name, transformFunction);\n                    return;\n                }\n            }\n            var destination = propertyMapping.destination;\n            // if (!propertyMapping.destination) {\n            //     // it makes no sense to handle a property without destination(s).\n            //     this.throwMappingException(propertyMapping, 'no destination object');\n            // }\n            var configurationOptions = this.createMemberConfigurationOptions(sourceObject, sourcePropertyName);\n            transformFunction(destination, configurationOptions);\n        };\n        AutoMapperBase.prototype.createMemberConfigurationOptions = function (sourceObject, sourcePropertyName) {\n            var memberConfigurationOptions = {\n                mapFrom: function (sourcePropertyName) {\n                    // no action required, just here as a stub to prevent calling a non-existing 'opts.mapFrom(...)' function.\n                },\n                condition: function (predicate) {\n                    // no action required, just here as a stub to prevent calling a non-existing 'opts.condition(...)' function.\n                },\n                ignore: function () {\n                    // no action required, just here as a stub to prevent calling a non-existing 'opts.ignore()' function.\n                },\n                sourceObject: sourceObject,\n                sourcePropertyName: sourcePropertyName,\n                intermediatePropertyValue: sourceObject ? sourceObject[sourcePropertyName] : sourceObject\n            };\n            return memberConfigurationOptions;\n        };\n        return AutoMapperBase;\n    }());\n    AutoMapperJs.AutoMapperBase = AutoMapperBase;\n})(AutoMapperJs || (AutoMapperJs = {}));\n\n//# sourceMappingURL=AutoMapperBase.js.map\n","/// <reference path=\"../../dist/automapper-interfaces.d.ts\" />\n/// <reference path=\"AutoMapper.ts\" />\n/// <reference path=\"TypeConverter.ts\" />\n/// <reference path=\"AutoMapperHelper.ts\" />\n/// <reference path=\"AutoMapperValidator.ts\" />\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar AutoMapperJs;\n(function (AutoMapperJs) {\n    'use strict';\n    /**\n     * AsyncAutoMapper implementation, for asynchronous mapping support when using AutoMapper.\n     */\n    var AsyncAutoMapper = (function (_super) {\n        __extends(AsyncAutoMapper, _super);\n        function AsyncAutoMapper() {\n            var _this = _super.call(this) || this;\n            AsyncAutoMapper.asyncInstance = _this;\n            return _this;\n        }\n        AsyncAutoMapper.prototype.createMap = function (sourceKeyOrType, destinationKeyOrType) {\n            throw new Error('Method AsyncAutoMapper.createMap is not implemented.');\n        };\n        AsyncAutoMapper.prototype.createMapForMember = function (mapping, property) {\n            var _this = this;\n            mapping.async = true;\n            mapping.mapItemFunction = function (m, srcObj, dstObj, cb) { return _this.mapItem(m, srcObj, dstObj, cb); };\n            // property.async = true;\n            // property.conversionValuesAndFunctions.push(func);\n        };\n        AsyncAutoMapper.prototype.createMapConvertUsing = function (mapping, converterFunction) {\n            var _this = this;\n            mapping.async = true;\n            mapping.typeConverterFunction = converterFunction;\n            mapping.mapItemFunction = function (m, srcObj, dstObj, cb) { return _this.mapItemUsingTypeConverter(m, srcObj, dstObj, cb); };\n        };\n        AsyncAutoMapper.prototype.map = function (mappings, sourceKey, destinationKey, sourceObject, callback) {\n            var _this = this;\n            switch (arguments.length) {\n                case 5:\n                    this.mapWithMapping(_super.prototype.getMapping.call(this, mappings, sourceKey, destinationKey), sourceObject, callback);\n                    return;\n                // provide performance optimized (preloading) currying support.\n                case 4:\n                    return function (cb) { return _this.mapWithMapping(_super.prototype.getMapping.call(_this, mappings, sourceKey, destinationKey), sourceObject, cb); };\n                case 3:\n                    return function (srcObj, cb) { return _this.mapWithMapping(_super.prototype.getMapping.call(_this, mappings, sourceKey, destinationKey), srcObj, cb); };\n                case 2:\n                    return function (dstKey, srcObj, cb) { return _this.map(mappings, sourceKey, dstKey, srcObj, cb); };\n                default:\n                    throw new Error('The AsyncAutoMapper.map function expects between 2 and 5 parameters, you provided ' + arguments.length + '.');\n            }\n        };\n        AsyncAutoMapper.prototype.mapWithMapping = function (mapping, sourceObject, callback) {\n            if (_super.prototype.isArray.call(this, sourceObject)) {\n                this.mapArray(mapping, sourceObject, callback);\n                return;\n            }\n            return mapping.mapItemFunction(mapping, sourceObject, _super.prototype.createDestinationObject.call(this, mapping.destinationTypeClass), callback);\n        };\n        /**\n         * Execute a mapping from the source array to a new destination array with explicit mapping configuration and supplied mapping options (using createMap).\n         * @param mapping The mapping configuration for the current mapping keys/types.\n         * @param sourceArray The source array to map.\n         * @returns {Array<any>} Destination array.\n         */\n        AsyncAutoMapper.prototype.mapArray = function (mapping, sourceArray, callback) {\n            var callbacksToGo = 0;\n            var destinationArray = _super.prototype.handleArray.call(this, mapping, sourceArray, function (sourceObject, destinationObject) {\n                callbacksToGo++;\n                mapping.mapItemFunction(mapping, sourceObject, destinationObject, function (result) {\n                    callbacksToGo--;\n                });\n            });\n            var waitForCallbackToSend = function () {\n                if (callbacksToGo === 0) {\n                    callback(destinationArray);\n                }\n                else {\n                    setTimeout(function () {\n                        waitForCallbackToSend();\n                    }, 10 * callbacksToGo);\n                }\n            };\n            waitForCallbackToSend();\n        };\n        AsyncAutoMapper.prototype.mapItemUsingTypeConverter = function (mapping, sourceObject, destinationObject, callback) {\n            var resolutionContext = {\n                sourceValue: sourceObject,\n                destinationValue: destinationObject\n            };\n            mapping.typeConverterFunction(resolutionContext, callback);\n        };\n        /**\n         * Execute a mapping from the source object to a new destination object with explicit mapping configuration and supplied mapping options (using createMap).\n         * @param mapping The mapping configuration for the current mapping keys/types.\n         * @param sourceObject The source object to map.\n         * @param destinationObject The destination object to map to.\n         * @param callback The callback to call after async mapping has been executed.\n         */\n        AsyncAutoMapper.prototype.mapItem = function (mapping, sourceObject, destinationObject, callback) {\n            var _this = this;\n            var callbacksToGo = 0;\n            _super.prototype.handleItem.call(this, mapping, sourceObject, destinationObject, function (sourceProperty) {\n                callbacksToGo++;\n                _this.mapProperty(mapping, sourceObject, sourceProperty, destinationObject, function (result) {\n                    callbacksToGo--;\n                });\n            });\n            var waitForCallbackToSend = function () {\n                if (callbacksToGo === 0) {\n                    callback(destinationObject);\n                }\n                else {\n                    setTimeout(function () {\n                        waitForCallbackToSend();\n                    }, 10 * callbacksToGo);\n                }\n            };\n            waitForCallbackToSend();\n        };\n        /**\n         * Execute a mapping from the source object property to the destination object property with explicit mapping configuration and supplied mapping options.\n         * @param mapping The mapping configuration for the current mapping keys/types.\n         * @param sourceObject The source object to map.\n         * @param sourcePropertyName The source property to map.\n         * @param destinationObject The destination object to map to.\n         * @param callback The callback to call after async property mapping has been executed.\n         */\n        AsyncAutoMapper.prototype.mapProperty = function (mapping, sourceObject, sourceProperty, destinationObject, callback) {\n            var _this = this;\n            _super.prototype.handleProperty.call(this, mapping, sourceObject, sourceProperty, destinationObject, function (destinationProperty, options) {\n                _this.transform(mapping, sourceObject, destinationProperty, destinationObject, options, function (destinationPropertyValue, success) {\n                    callback(destinationPropertyValue);\n                });\n            }, function (destinationPropertyValue) {\n                callback(destinationPropertyValue);\n            });\n        };\n        AsyncAutoMapper.prototype.transform = function (mapping, sourceObject, destinationProperty, destinationObject, options, callback) {\n            var _this = this;\n            var childDestinationProperty = destinationProperty.child;\n            if (childDestinationProperty) {\n                var childDestinationObject = destinationObject[destinationProperty.name];\n                if (!childDestinationObject) {\n                    // no child source object? create.\n                    childDestinationObject = {};\n                }\n                // transform child by recursively calling the transform function.\n                this.transform(mapping, sourceObject, childDestinationProperty, childDestinationObject, options, function (callbackValue, success) {\n                    if (success) {\n                        // only set child destination object when transformation has been successful.\n                        destinationObject[destinationProperty.name] = childDestinationObject;\n                    }\n                    callback(options.intermediatePropertyValue, success);\n                });\n                return;\n            }\n            if (!_super.prototype.shouldProcessDestination.call(this, destinationProperty, sourceObject)) {\n                callback(undefined /* opts.intermediatePropertyValue */, false);\n                return;\n            }\n            // actually transform destination property.\n            this.processTransformations(destinationProperty, destinationProperty.transformations, options, function (callbackValue, success) {\n                if (success) {\n                    _super.prototype.setPropertyValue.call(_this, mapping, destinationProperty, destinationObject, options.intermediatePropertyValue);\n                }\n                callback(options.intermediatePropertyValue, success);\n            });\n        };\n        AsyncAutoMapper.prototype.processTransformations = function (property, transformations, options, callback) {\n            var _this = this;\n            if (transformations.length === 0) {\n                callback(options.intermediatePropertyValue, true);\n                return;\n            }\n            var transformation = transformations[0];\n            this.processTransformation(property, transformation, options, function (callbackValue, success) {\n                if (!success) {\n                    callback(options.intermediatePropertyValue, false);\n                    return;\n                }\n                _this.processTransformations(property, transformations.slice(1), options, callback);\n            });\n        };\n        AsyncAutoMapper.prototype.processTransformation = function (property, transformation, options, callback) {\n            switch (transformation.transformationType) {\n                case AutoMapperJs.DestinationTransformationType.Constant:\n                    options.intermediatePropertyValue = transformation.constant;\n                    callback(options.intermediatePropertyValue, true);\n                    return;\n                case AutoMapperJs.DestinationTransformationType.MemberOptions: {\n                    var result = transformation.memberConfigurationOptionsFunc(options);\n                    if (typeof result !== 'undefined') {\n                        options.intermediatePropertyValue = result;\n                    }\n                    else if (!options.sourceObject) {\n                        callback(options.intermediatePropertyValue, false);\n                        return;\n                    }\n                    callback(options.intermediatePropertyValue, true);\n                    return;\n                }\n                case AutoMapperJs.DestinationTransformationType.SourceMemberOptions: {\n                    var result = transformation.sourceMemberConfigurationOptionsFunc(options);\n                    if (typeof result !== 'undefined') {\n                        options.intermediatePropertyValue = result;\n                    }\n                    else if (!options.sourceObject) {\n                        callback(options.intermediatePropertyValue, false);\n                        return;\n                    }\n                    callback(options.intermediatePropertyValue, true);\n                    return;\n                }\n                case AutoMapperJs.DestinationTransformationType.AsyncMemberOptions:\n                    transformation.asyncMemberConfigurationOptionsFunc(options, function (result) {\n                        if (typeof result !== 'undefined') {\n                            options.intermediatePropertyValue = result;\n                        }\n                        callback(options.intermediatePropertyValue, true);\n                        return;\n                    });\n                    return;\n                case AutoMapperJs.DestinationTransformationType.AsyncSourceMemberOptions:\n                    transformation.asyncSourceMemberConfigurationOptionsFunc(options, function (result) {\n                        if (typeof result !== 'undefined') {\n                            options.intermediatePropertyValue = result;\n                        }\n                        callback(options.intermediatePropertyValue, true);\n                        return;\n                    });\n                    return;\n                default:\n                    // TODO: this.throwMappingException(property, `AutoMapper.handlePropertyMappings: Unexpected transformation type ${transformation}`);\n                    callback(options.intermediatePropertyValue, false);\n                    return;\n            }\n        };\n        return AsyncAutoMapper;\n    }(AutoMapperJs.AutoMapperBase));\n    AsyncAutoMapper.asyncInstance = new AsyncAutoMapper();\n    AutoMapperJs.AsyncAutoMapper = AsyncAutoMapper;\n})(AutoMapperJs || (AutoMapperJs = {}));\n\n//# sourceMappingURL=AsyncAutoMapper.js.map\n","/// <reference path=\"../../dist/automapper-interfaces.d.ts\" />\n/// <reference path=\"AutoMapperEnumerations.ts\" />\n/// <reference path=\"AutoMapperBase.ts\" />\n/// <reference path=\"AsyncAutoMapper.ts\" />\n/// <reference path=\"TypeConverter.ts\" />\n/// <reference path=\"AutoMapperHelper.ts\" />\n/// <reference path=\"AutoMapperValidator.ts\" />\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar AutoMapperJs;\n(function (AutoMapperJs) {\n    'use strict';\n    var AutoMapper = (function (_super) {\n        __extends(AutoMapper, _super);\n        /**\n         * This class is intended to be a Singleton. Preferrably use getInstance()\n         * function instead of using the constructor directly from code.\n         */\n        function AutoMapper() {\n            var _this = _super.call(this) || this;\n            if (AutoMapper._instance) {\n                return AutoMapper._instance;\n            }\n            else {\n                AutoMapper._instance = _this;\n                _this._profiles = {};\n                _this._mappings = {};\n                _this._asyncMapper = new AutoMapperJs.AsyncAutoMapper();\n            }\n            return _this;\n        }\n        AutoMapper.getInstance = function () {\n            return AutoMapper._instance;\n        };\n        /**\n         * Initializes the mapper with the supplied configuration.\n         * @param {(config: IConfiguration) => void} configFunction Configuration function to call.\n         */\n        AutoMapper.prototype.initialize = function (configFunction) {\n            var that = this;\n            var configuration = {\n                addProfile: function (profile) {\n                    profile.configure();\n                    that._profiles[profile.profileName] = profile;\n                },\n                createMap: function (sourceKey, destinationKey) {\n                    // pass through using arguments to keep createMap's currying support fully functional.\n                    return that.createMap.apply(that, arguments);\n                }\n            };\n            configFunction(configuration);\n        };\n        /**\n         * Create a mapping profile.\n         * @param {string} sourceKey The map source key.\n         * @param {string} destinationKey The map destination key.\n         * @returns {Core.ICreateMapFluentFunctions}\n         */\n        AutoMapper.prototype.createMap = function (sourceKeyOrType, destinationKeyOrType) {\n            // provide currying support.\n            if (arguments.length < 2) {\n                return AutoMapperJs.AutoMapperHelper.handleCurrying(this.createMap, arguments, this);\n            }\n            var mapping = this.createMappingObjectForGivenKeys(sourceKeyOrType, destinationKeyOrType);\n            return this.createMapGetFluentApiFunctions(mapping);\n        };\n        /**\n         * Execute a mapping from the source object to a new destination object with explicit mapping configuration and supplied mapping options (using createMap).\n         * @param sourceKey Source key, for instance the source type name.\n         * @param destinationKey Destination key, for instance the destination type name.\n         * @param sourceObject The source object to map.\n         * @returns {any} Destination object.\n         */\n        AutoMapper.prototype.map = function (sourceKeyOrType, destinationKeyOrType, sourceObject) {\n            var _this = this;\n            if (arguments.length === 3) {\n                return this.mapInternal(_super.prototype.getMapping.call(this, this._mappings, sourceKeyOrType, destinationKeyOrType), sourceObject);\n            }\n            // provide performance optimized (preloading) currying support.\n            if (arguments.length === 2) {\n                return function (srcObj) { return _this.mapInternal(_super.prototype.getMapping.call(_this, _this._mappings, sourceKeyOrType, destinationKeyOrType), srcObj); };\n            }\n            if (arguments.length === 1) {\n                return function (dstKey, srcObj) { return _this.map(sourceKeyOrType, dstKey, srcObj); };\n            }\n            return function (srcKey, dstKey, srcObj) { return _this.map(srcKey, dstKey, srcObj); };\n        };\n        /**\n         * Execute an asynchronous mapping from the source object to a new destination object with explicit mapping configuration and supplied mapping options (using createMap).\n         * @param sourceKey Source key, for instance the source type name.\n         * @param destinationKey Destination key, for instance the destination type name.\n         * @param sourceObject The source object to map.\n         * @param {IMapCallback} callback The callback to call when asynchronous mapping is complete.\n         */\n        AutoMapper.prototype.mapAsync = function (sourceKeyOrType, destinationKeyOrType, sourceObject, callback) {\n            switch (arguments.length) {\n                case 4:\n                    return this._asyncMapper.map(this._mappings, sourceKeyOrType, destinationKeyOrType, sourceObject, callback);\n                case 3:\n                    return this._asyncMapper.map(this._mappings, sourceKeyOrType, destinationKeyOrType, sourceObject);\n                case 2:\n                    return this._asyncMapper.map(this._mappings, sourceKeyOrType, destinationKeyOrType);\n                case 1:\n                    return this._asyncMapper.map(this._mappings, sourceKeyOrType);\n                default:\n                    throw new Error('The mapAsync function expects between 1 and 4 parameters, you provided ' + arguments.length + '.');\n            }\n        };\n        /**\n         * Validates mapping configuration by dry-running. Since JS does not fully support typing, it only checks if properties match on both\n         * sides. The function needs IMapping.sourceTypeClass and IMapping.destinationTypeClass to function.\n         * @param {boolean} strictMode Whether or not to fail when properties sourceTypeClass or destinationTypeClass are unavailable.\n         */\n        AutoMapper.prototype.assertConfigurationIsValid = function (strictMode) {\n            if (strictMode === void 0) { strictMode = true; }\n            AutoMapperJs.AutoMapperValidator.assertConfigurationIsValid(this._mappings, strictMode);\n        };\n        AutoMapper.prototype.createMapForAllMembers = function (mapping, fluentFunc, func) {\n            mapping.forAllMemberMappings.push(func);\n            return fluentFunc;\n        };\n        AutoMapper.prototype.createMapIgnoreAllNonExisting = function (mapping, fluentFunc) {\n            mapping.ignoreAllNonExisting = true;\n            return fluentFunc;\n        };\n        AutoMapper.prototype.createMapConvertToType = function (mapping, fluentFunc, typeClass) {\n            if (mapping.destinationTypeClass) {\n                throw new Error('Destination type class can only be set once.');\n            }\n            mapping.destinationTypeClass = typeClass;\n            return fluentFunc;\n        };\n        AutoMapper.prototype.createMapConvertUsing = function (mapping, tcClassOrFunc) {\n            var _this = this;\n            var configureSynchronousConverterFunction = function (converterFunc) {\n                if (!converterFunc || AutoMapperJs.AutoMapperHelper.getFunctionParameters(converterFunc.toString()).length !== 1) {\n                    throw new Error('The function provided does not provide exactly one (resolutionContext) parameter.');\n                }\n                mapping.typeConverterFunction = converterFunc;\n                mapping.mapItemFunction = function (m, srcObj, dstObj) { return _this.mapItemUsingTypeConverter(m, srcObj, dstObj); };\n            };\n            try {\n                // check if sync: TypeConverter instance\n                if (tcClassOrFunc instanceof AutoMapperJs.TypeConverter) {\n                    configureSynchronousConverterFunction(tcClassOrFunc.convert);\n                    return;\n                }\n                var functionParameters = AutoMapperJs.AutoMapperHelper.getFunctionParameters(tcClassOrFunc.toString());\n                switch (functionParameters.length) {\n                    case 0:\n                        // check if sync: TypeConverter class definition\n                        var typeConverter;\n                        try {\n                            typeConverter = new tcClassOrFunc();\n                        }\n                        catch (e) {\n                            // Obviously, typeConverterClassOrFunction is not a TypeConverter class definition\n                        }\n                        if (typeConverter instanceof AutoMapperJs.TypeConverter) {\n                            configureSynchronousConverterFunction(typeConverter.convert);\n                            return;\n                        }\n                        break;\n                    case 1:\n                        // sync: function with resolutionContext parameter\n                        configureSynchronousConverterFunction(tcClassOrFunc);\n                        return;\n                    case 2:\n                        // check if async: function with resolutionContext and callback parameters\n                        this._asyncMapper.createMapConvertUsing(mapping, tcClassOrFunc);\n                        return;\n                }\n                // okay, just try feeding the function to the configure function anyway...\n                configureSynchronousConverterFunction(tcClassOrFunc);\n            }\n            catch (e) {\n                throw new Error(\"The value provided for typeConverterClassOrFunction is invalid. \" + e);\n            }\n        };\n        AutoMapper.prototype.createMapWithProfile = function (mapping, profileName) {\n            // check if given profile exists\n            var profile = this._profiles[profileName];\n            if (typeof profile === 'undefined' || profile.profileName !== profileName) {\n                throw new Error(\"Could not find profile with profile name '\" + profileName + \"'.\");\n            }\n            mapping.profile = profile;\n            // merge mappings\n            this.createMapWithProfileMergeMappings(mapping, profileName);\n        };\n        AutoMapper.prototype.createMapWithProfileMergeMappings = function (mapping, profileName) {\n            var profileMappingKey = profileName + \"=>\" + mapping.sourceKey + profileName + \"=>\" + mapping.destinationKey;\n            var profileMapping = this._mappings[profileMappingKey];\n            if (!profileMapping) {\n                return;\n            }\n            // append forAllMemberMappings calls to the original array.\n            if (profileMapping.forAllMemberMappings.length > 0) {\n                (_a = mapping.forAllMemberMappings).push.apply(_a, profileMapping.forAllMemberMappings);\n            }\n            // overwrite original type converter function\n            if (profileMapping.typeConverterFunction) {\n                mapping.typeConverterFunction = profileMapping.typeConverterFunction;\n                mapping.mapItemFunction = profileMapping.mapItemFunction;\n            }\n            // overwrite original type converter function\n            if (profileMapping.destinationTypeClass) {\n                mapping.destinationTypeClass = profileMapping.destinationTypeClass;\n            }\n            // walk through all the profile's property mappings\n            for (var _i = 0, _b = profileMapping.properties; _i < _b.length; _i++) {\n                var property = _b[_i];\n                // TODO Awkward way of locating sourceMapping ;) ...\n                var sourceMapping = this.getDestinationProperty(property.destinationPropertyName, property).sourceMapping;\n                if (!this.mergeSourceProperty(property, mapping.properties, sourceMapping)) {\n                    mapping.properties.push(property);\n                }\n            }\n            var _a;\n        };\n        AutoMapper.prototype.mapInternal = function (mapping, sourceObject) {\n            if (sourceObject === null || typeof sourceObject === 'undefined') {\n                return sourceObject;\n            }\n            if (mapping.async) {\n                throw new Error('Impossible to use asynchronous mapping using automapper.map(); use automapper.mapAsync() instead.');\n            }\n            if (_super.prototype.isArray.call(this, sourceObject)) {\n                return this.mapArray(mapping, sourceObject);\n            }\n            return mapping.mapItemFunction(mapping, sourceObject, _super.prototype.createDestinationObject.call(this, mapping.destinationTypeClass));\n        };\n        AutoMapper.prototype.mapArray = function (mapping, sourceArray) {\n            var destinationArray = _super.prototype.handleArray.call(this, mapping, sourceArray, function (sourceObject, destinationObject) {\n                mapping.mapItemFunction(mapping, sourceObject, destinationObject);\n            });\n            return destinationArray;\n        };\n        AutoMapper.prototype.mapItem = function (mapping, sourceObject, destinationObject) {\n            var _this = this;\n            destinationObject = _super.prototype.handleItem.call(this, mapping, sourceObject, destinationObject, function (propertyName) {\n                _this.mapProperty(mapping, sourceObject, destinationObject, propertyName);\n            });\n            return destinationObject;\n        };\n        AutoMapper.prototype.mapItemUsingTypeConverter = function (mapping, sourceObject, destinationObject, arrayIndex) {\n            var resolutionContext = {\n                sourceValue: sourceObject,\n                destinationValue: destinationObject\n            };\n            return mapping.typeConverterFunction(resolutionContext);\n        };\n        AutoMapper.prototype.mapProperty = function (mapping, sourceObject, destinationObject, sourceProperty) {\n            var _this = this;\n            _super.prototype.handleProperty.call(this, mapping, sourceObject, sourceProperty, destinationObject, function (destinationProperty, options) {\n                return _this.transform(mapping, sourceObject, destinationProperty, destinationObject, options);\n            });\n        };\n        AutoMapper.prototype.transform = function (mapping, sourceObject, destinationProperty, destinationObject, options) {\n            var childDestinationProperty = destinationProperty.child;\n            if (childDestinationProperty) {\n                var childDestinationObject = destinationObject[destinationProperty.name];\n                if (!childDestinationObject) {\n                    // no child source object? create.\n                    childDestinationObject = {};\n                }\n                // transform child by recursively calling the transform function.\n                var transformed = this.transform(mapping, sourceObject, childDestinationProperty, childDestinationObject, options /*, callback*/);\n                if (transformed) {\n                    // only set child destination object when transformation has been successful.\n                    destinationObject[destinationProperty.name] = childDestinationObject;\n                }\n                return transformed;\n            }\n            if (!_super.prototype.shouldProcessDestination.call(this, destinationProperty, sourceObject)) {\n                return false;\n            }\n            // actually transform destination property.\n            for (var _i = 0, _a = destinationProperty.transformations; _i < _a.length; _i++) {\n                var transformation = _a[_i];\n                if (!this.processTransformation(destinationProperty, transformation, options)) {\n                    return false;\n                }\n            }\n            _super.prototype.setPropertyValue.call(this, mapping, destinationProperty, destinationObject, options.intermediatePropertyValue);\n            return true;\n        };\n        AutoMapper.prototype.processTransformation = function (property, transformation, options) {\n            switch (transformation.transformationType) {\n                case AutoMapperJs.DestinationTransformationType.Constant:\n                    options.intermediatePropertyValue = transformation.constant;\n                    return true;\n                case AutoMapperJs.DestinationTransformationType.MemberOptions: {\n                    var result = transformation.memberConfigurationOptionsFunc(options);\n                    if (typeof result !== 'undefined') {\n                        options.intermediatePropertyValue = result;\n                    }\n                    else if (!options.sourceObject) {\n                        return false;\n                    }\n                    return true;\n                }\n                case AutoMapperJs.DestinationTransformationType.SourceMemberOptions: {\n                    var result = transformation.sourceMemberConfigurationOptionsFunc(options);\n                    if (typeof result !== 'undefined') {\n                        options.intermediatePropertyValue = result;\n                    }\n                    else if (!options.sourceObject) {\n                        return false;\n                    }\n                    return true;\n                }\n                default:\n                    // this.throwMappingException(property, `AutoMapper.handlePropertyMappings: Unexpected transformation type ${transformation.transformationType}`);\n                    return false;\n            }\n        };\n        AutoMapper.prototype.createMappingObjectForGivenKeys = function (srcKeyOrType, dstKeyOrType) {\n            var _this = this;\n            var mapping = {\n                sourceKey: _super.prototype.getKey.call(this, srcKeyOrType),\n                destinationKey: _super.prototype.getKey.call(this, dstKeyOrType),\n                forAllMemberMappings: new Array(),\n                properties: [],\n                typeConverterFunction: undefined,\n                mapItemFunction: function (m, srcObj, dstObj) { return _this.mapItem(m, srcObj, dstObj); },\n                sourceTypeClass: (typeof srcKeyOrType === 'string' ? undefined : srcKeyOrType),\n                destinationTypeClass: (typeof dstKeyOrType === 'string' ? undefined : dstKeyOrType),\n                profile: undefined,\n                async: false\n            };\n            this._mappings[mapping.sourceKey + mapping.destinationKey] = mapping;\n            return mapping;\n        };\n        AutoMapper.prototype.createMapGetFluentApiFunctions = function (mapping) {\n            var _this = this;\n            // create a fluent interface / method chaining (e.g. automapper.createMap().forMember().forMember() ...)\n            var fluentFunc = {\n                forMember: function (prop, valFunc) {\n                    return _this.createMapForMember({ mapping: mapping, propertyName: prop, transformation: valFunc, sourceMapping: false, fluentFunctions: fluentFunc });\n                },\n                forSourceMember: function (prop, cfgFunc) {\n                    return _this.createMapForMember({ mapping: mapping, propertyName: prop, transformation: cfgFunc, sourceMapping: true, fluentFunctions: fluentFunc });\n                },\n                forAllMembers: function (func) {\n                    return _this.createMapForAllMembers(mapping, fluentFunc, func);\n                },\n                ignoreAllNonExisting: function () { return _this.createMapIgnoreAllNonExisting(mapping, fluentFunc); },\n                convertToType: function (type) { return _this.createMapConvertToType(mapping, fluentFunc, type); },\n                convertUsing: function (tcClassOrFunc) {\n                    return _this.createMapConvertUsing(mapping, tcClassOrFunc);\n                },\n                withProfile: function (profile) { return _this.createMapWithProfile(mapping, profile); }\n            };\n            return fluentFunc;\n        };\n        AutoMapper.prototype.createMapForMember = function (parameters) {\n            var mapping = parameters.mapping, propertyName = parameters.propertyName, transformation = parameters.transformation, sourceMapping = parameters.sourceMapping, fluentFunctions = parameters.fluentFunctions;\n            // extract source/destination property names\n            var metadata = AutoMapperJs.AutoMapperHelper.getMappingMetadataFromTransformationFunction(propertyName, transformation, sourceMapping);\n            this.validateForMemberParameters(metadata);\n            var source = metadata.source, destination = metadata.destination;\n            // create property (regardless of current existance)\n            var property = this.createSourceProperty(metadata, null);\n            // merge with existing property or add property\n            if (!this.mergeSourceProperty(property, mapping.properties, sourceMapping)) {\n                mapping.properties.push(property);\n            }\n            if (metadata.async) {\n                this._asyncMapper.createMapForMember(mapping, this.findProperty(property.name, mapping.properties));\n            }\n            return fluentFunctions;\n        };\n        AutoMapper.prototype.validateForMemberParameters = function (metadata) {\n            if (!metadata.sourceMapping) {\n                return;\n            }\n            // validate forSourceMember parameters\n            if (metadata.transformation.transformationType === AutoMapperJs.DestinationTransformationType.Constant) {\n                throw new Error('Configuration of forSourceMember has to be a function with one (sync) or two (async) options parameters.');\n            }\n        };\n        AutoMapper.prototype.createSourceProperty = function (metadata, parent) {\n            var level = !parent ? 0 : parent.level + 1;\n            var sourceNameParts = metadata.source.split('.');\n            var source = {\n                name: sourceNameParts[level],\n                sourcePropertyName: metadata.source,\n                destinationPropertyName: metadata.destination,\n                parent: parent,\n                level: level,\n                children: [],\n                destination: null\n            };\n            if ((level + 1) < sourceNameParts.length) {\n                // recursively add child source properties ...\n                var child = this.createSourceProperty(metadata, source);\n                if (child) {\n                    source.children.push(child);\n                }\n                source.destination = null;\n            }\n            else {\n                // ... or (!) add destination\n                source.destination = this.createDestinationProperty(metadata, null);\n            }\n            return source;\n        };\n        AutoMapper.prototype.createDestinationProperty = function (metadata, parent) {\n            var level = !parent ? 0 : parent.level + 1;\n            var destinationNameParts = metadata.destination.split('.');\n            var destination = {\n                name: destinationNameParts[level],\n                sourcePropertyName: metadata.source,\n                destinationPropertyName: metadata.destination,\n                parent: parent,\n                level: level,\n                child: null,\n                transformations: [],\n                conditionFunction: null,\n                ignore: false,\n                sourceMapping: false\n            };\n            if ((level + 1) < destinationNameParts.length) {\n                // recursively add child destination properties\n                destination.child = this.createDestinationProperty(metadata, destination);\n            }\n            else {\n                // add/merge properties\n                destination.sourceMapping = metadata.sourceMapping;\n                destination.conditionFunction = metadata.condition;\n                destination.ignore = metadata.ignore;\n                destination.transformations.push(metadata.transformation);\n            }\n            return destination;\n        };\n        AutoMapper.prototype.mergeSourceProperty = function (property, existingProperties, sourceMapping) {\n            // find source property\n            var existing = sourceMapping\n                ? this.findProperty(property.name, existingProperties)\n                : this.matchSourcePropertyByDestination(property, existingProperties);\n            if (!existing) {\n                return false;\n            }\n            if (property.destination) {\n                if (existing.children.length > 0) {\n                    var existingDestination = this.getDestinationProperty(existing.destinationPropertyName, existing);\n                    // existing is (further) nested => rebase and/or merge\n                    if (this.handleMapFromProperties(property, existing)) {\n                        // merge and rebase existing destination to current source level\n                        if (!this.mergeDestinationProperty(property.destination, existingDestination)) {\n                            return false;\n                        }\n                        existing.destination = existingDestination;\n                        existing.children = [];\n                        return true;\n                    }\n                    // merge property.destination with existing mapFrom() destination (don't care about nesting depth here)\n                    return this.mergeDestinationProperty(property.destination, existingDestination);\n                }\n                // both are at same level => simple merge.\n                if (!this.mergeDestinationProperty(property.destination, existing.destination)) {\n                    return false;\n                }\n                this.handleMapFromProperties(property, existing);\n                return true;\n            }\n            // new source is (further) nested (has children).\n            if (existing.children.length > 0) {\n                // both have further nesting, delegate merging child(ren) by recursively calling this function.\n                for (var _i = 0, _a = property.children; _i < _a.length; _i++) {\n                    var child = _a[_i];\n                    if (!this.mergeSourceProperty(child, existing.children, sourceMapping)) {\n                        return false;\n                    }\n                }\n                if (property.destinationPropertyName !== property.sourcePropertyName) {\n                    // this is a mapFrom() registration. It is handled using the nested source properties,\n                    // we only are responsible for syncing the name properties.\n                    existing.name = property.name;\n                    existing.sourcePropertyName = property.sourcePropertyName;\n                }\n                return true;\n            }\n            // existing is not (further) nested. this is always a mapFrom() situation.\n            // if (property.sourcePropertyName !== existing.sourcePropertyName) {\n            var newDestination = this.getDestinationProperty(existing.destinationPropertyName, property);\n            if (property.destinationPropertyName !== property.sourcePropertyName) {\n                // this is a mapFrom() registration. In that case:\n                // 1) merge destinations, 2) add source child and 3) move destination to (youngest) child\n                // NOTE special mergeDestinationProperty call => we use the new destination as 'target',\n                //      because that will save us trouble overwriting ;)...\n                if (!this.mergeDestinationProperty(existing.destination, newDestination, true)) {\n                    return false;\n                }\n                existing.children = property.children;\n                existing.name = property.name;\n                existing.sourcePropertyName = property.sourcePropertyName;\n                existing.destination = null;\n                // TODO Should never be necessary (test): existing.destinationPropertyName = property.destinationPropertyName;\n                return true;\n            }\n            // ... nope, it is a destination which has previously been registered using mapFrom. just merge\n            return this.mergeDestinationProperty(newDestination, existing.destination);\n            // }\n        };\n        /**\n         * handle property naming when the current property to merge is a mapFrom property\n         */\n        AutoMapper.prototype.handleMapFromProperties = function (property, existingProperty) {\n            if (property.destinationPropertyName === property.sourcePropertyName ||\n                property.sourcePropertyName === existingProperty.sourcePropertyName) {\n                return false;\n            }\n            // only overwrite name when a mapFrom situation applies\n            existingProperty.name = property.name;\n            existingProperty.sourcePropertyName = property.sourcePropertyName;\n            // TODO Should never be necessary (test) => existingProperty.destinationPropertyName = property.destinationPropertyName;\n            return true;\n        };\n        AutoMapper.prototype.getDestinationProperty = function (destinationPropertyName, existingSource) {\n            if (existingSource.destination) {\n                return existingSource.destination;\n            }\n            for (var _i = 0, _a = existingSource.children; _i < _a.length; _i++) {\n                var child = _a[_i];\n                var destination = this.getDestinationProperty(destinationPropertyName, child);\n                if (destination) {\n                    return destination;\n                }\n            }\n            return null;\n        };\n        AutoMapper.prototype.mergeDestinationProperty = function (destination, existingDestination, swapTransformations) {\n            if (swapTransformations === void 0) { swapTransformations = false; }\n            if (destination.child) {\n                if (existingDestination.child) {\n                    // both have further nesting, delegate merging children by recursively calling this function.\n                    if (!this.mergeDestinationProperty(destination.child, existingDestination.child, swapTransformations)) {\n                        return false;\n                    }\n                    this.handleMapFromProperties(destination, existingDestination);\n                    return true;\n                }\n                // the current destination is not (further) nested. a destination property registration has one of both:\n                // a) children or b) transformations. returning false will cause creating a duplicate source property entry instead.\n                return false;\n            }\n            if (existingDestination.sourceMapping !== destination.sourceMapping &&\n                existingDestination.sourcePropertyName !== destination.sourcePropertyName) {\n                // unable to perform mapFrom() on a property which is being registered using forSourceMember.\n                return false; // TODO: Unpredictable? Idea: throw new Error('Unable to perform mapFrom() on a property which is being registered using forSourceMember.');\n            }\n            // merge destination properties\n            if (destination.sourceMapping) {\n                // only set source mapping when not yet set to true, once source mapped is source mapped forever.\n                // TODO Verify edge cases!\n                existingDestination.sourceMapping = destination.sourceMapping;\n            }\n            if (destination.ignore) {\n                // only set ignore when not yet set, once ignored is ignored forever.\n                existingDestination.ignore = destination.ignore;\n            }\n            if (destination.conditionFunction) {\n                // overwrite condition function by the latest one specified.\n                existingDestination.conditionFunction = destination.conditionFunction;\n            }\n            var transformations = [];\n            if (swapTransformations) {\n                for (var _i = 0, _a = destination.transformations; _i < _a.length; _i++) {\n                    var transformation = _a[_i];\n                    transformations.push(transformation);\n                }\n                for (var _b = 0, _c = existingDestination.transformations; _b < _c.length; _b++) {\n                    var transformation = _c[_b];\n                    transformations.push(transformation);\n                }\n            }\n            else {\n                for (var _d = 0, _e = existingDestination.transformations; _d < _e.length; _d++) {\n                    var transformation = _e[_d];\n                    transformations.push(transformation);\n                }\n                for (var _f = 0, _g = destination.transformations; _f < _g.length; _f++) {\n                    var transformation = _g[_f];\n                    transformations.push(transformation);\n                }\n            }\n            existingDestination.transformations = transformations;\n            this.handleMapFromProperties(destination, existingDestination);\n            return true;\n        };\n        AutoMapper.prototype.matchSourcePropertyByDestination = function (source, properties) {\n            if (!properties) {\n                return null;\n            }\n            for (var _i = 0, properties_1 = properties; _i < properties_1.length; _i++) {\n                var property = properties_1[_i];\n                if (property.destinationPropertyName === source.destinationPropertyName) {\n                    return property;\n                }\n            }\n            return null;\n        };\n        AutoMapper.prototype.findProperty = function (name, properties) {\n            if (!properties) {\n                return null;\n            }\n            for (var _i = 0, properties_2 = properties; _i < properties_2.length; _i++) {\n                var property = properties_2[_i];\n                if (property.name === name) {\n                    return property;\n                }\n            }\n            return null;\n        };\n        return AutoMapper;\n    }(AutoMapperJs.AutoMapperBase));\n    AutoMapper._instance = new AutoMapper();\n    AutoMapperJs.AutoMapper = AutoMapper;\n})(AutoMapperJs || (AutoMapperJs = {}));\n// Add AutoMapper to the application's global scope. Of course, you could still use Core.AutoMapper.getInstance() as well.\nvar automapper = (function (app) {\n    app.automapper = AutoMapperJs.AutoMapper.getInstance();\n    return app.automapper;\n})(this);\n\n//# sourceMappingURL=AutoMapper.js.map\n","/// <reference path=\"../../dist/automapper-interfaces.d.ts\" />\n/// <reference path=\"../../src/ts/AutoMapper.ts\" />\nvar AutoMapperJs;\n(function (AutoMapperJs) {\n    'use strict';\n    /**\n     * Converts source type to destination type instead of normal member mapping\n     */\n    var Profile = (function () {\n        function Profile() {\n        }\n        /**\n         * Implement this method in a derived class and call the CreateMap method to associate that map with this profile.\n         * Avoid calling the AutoMapper class / automapper instance from this method.\n         */\n        Profile.prototype.configure = function () {\n            // do nothing\n        };\n        /**\n         * Create a mapping profile.\n         * @param {string} sourceKey The map source key.\n         * @param {string} destinationKey The map destination key.\n         * @returns {Core.ICreateMapFluentFunctions}\n         */\n        Profile.prototype.createMap = function (sourceKey, destinationKey) {\n            var argsCopy = Array.prototype.slice.apply(arguments);\n            for (var index = 0, length = argsCopy.length; index < length; index++) {\n                if (argsCopy[index]) {\n                    // prefix sourceKey and destinationKey with 'profileName=>'\n                    argsCopy[index] = this.profileName + \"=>\" + argsCopy[index];\n                }\n            }\n            // pass through using arguments to keep createMap's currying support fully functional.\n            return automapper.createMap.apply(automapper, argsCopy);\n        };\n        return Profile;\n    }());\n    AutoMapperJs.Profile = Profile;\n})(AutoMapperJs || (AutoMapperJs = {}));\n\n//# sourceMappingURL=Profile.js.map\n","/// <reference path=\"../../dist/automapper-interfaces.d.ts\" />\nvar AutoMapperJs;\n(function (AutoMapperJs) {\n    'use strict';\n    /**\n     * Converts source type to destination type instead of normal member mapping\n     */\n    var TypeConverter = (function () {\n        function TypeConverter() {\n        }\n        /**\n         * Performs conversion from source to destination type.\n         * @param {IResolutionContext} resolutionContext Resolution context.\n         * @returns {any} Destination object.\n         */\n        TypeConverter.prototype.convert = function (resolutionContext) {\n            // NOTE BL Unfortunately, TypeScript/JavaScript do not support abstract base classes.\n            //         This is just one way around, please convince me about a better solution.\n            throw new Error('The TypeConverter.convert method is abstract. Use a TypeConverter extension class instead.');\n        };\n        return TypeConverter;\n    }());\n    AutoMapperJs.TypeConverter = TypeConverter;\n})(AutoMapperJs || (AutoMapperJs = {}));\n\n//# sourceMappingURL=TypeConverter.js.map\n","/// <reference path=\"../../../dist/automapper-interfaces.d.ts\" />\nvar AutoMapperJs;\n(function (AutoMapperJs) {\n    'use strict';\n    var CamelCaseNamingConvention = (function () {\n        function CamelCaseNamingConvention() {\n            this.splittingExpression = /(^[a-z]+(?=$|[A-Z]{1}[a-z0-9]+)|[A-Z]?[a-z0-9]+)/;\n            this.separatorCharacter = '';\n        }\n        CamelCaseNamingConvention.prototype.transformPropertyName = function (sourcePropertyNameParts) {\n            // Transform the splitted parts.\n            var result = '';\n            for (var index = 0, length = sourcePropertyNameParts.length; index < length; index++) {\n                if (index === 0) {\n                    result += sourcePropertyNameParts[index].charAt(0).toLowerCase() +\n                        sourcePropertyNameParts[index].substr(1);\n                }\n                else {\n                    result += sourcePropertyNameParts[index].charAt(0).toUpperCase() +\n                        sourcePropertyNameParts[index].substr(1);\n                }\n            }\n            return result;\n        };\n        return CamelCaseNamingConvention;\n    }());\n    AutoMapperJs.CamelCaseNamingConvention = CamelCaseNamingConvention;\n})(AutoMapperJs || (AutoMapperJs = {}));\n\n//# sourceMappingURL=CamelCaseNamingConvention.js.map\n","/// <reference path=\"../../../dist/automapper-interfaces.d.ts\" />\nvar AutoMapperJs;\n(function (AutoMapperJs) {\n    'use strict';\n    var PascalCaseNamingConvention = (function () {\n        function PascalCaseNamingConvention() {\n            this.splittingExpression = /(^[A-Z]+(?=$|[A-Z]{1}[a-z0-9]+)|[A-Z]?[a-z0-9]+)/;\n            this.separatorCharacter = '';\n        }\n        PascalCaseNamingConvention.prototype.transformPropertyName = function (sourcePropertyNameParts) {\n            // Transform the splitted parts.\n            var result = '';\n            for (var index = 0, length = sourcePropertyNameParts.length; index < length; index++) {\n                result += sourcePropertyNameParts[index].charAt(0).toUpperCase() +\n                    sourcePropertyNameParts[index].substr(1);\n                //if (index < (length - 1)) {\n                //    this.separatorCharacter;\n                //}\n            }\n            return result;\n        };\n        return PascalCaseNamingConvention;\n    }());\n    AutoMapperJs.PascalCaseNamingConvention = PascalCaseNamingConvention;\n})(AutoMapperJs || (AutoMapperJs = {}));\n\n//# sourceMappingURL=PascalCaseNamingConvention.js.map\n"]}